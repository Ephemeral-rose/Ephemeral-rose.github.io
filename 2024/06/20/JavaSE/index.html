<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    ephemeral-rose
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="empheral rose" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.0.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_solarized.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Ephemeral-rose</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Start/">Start</a></li><li><a class="category-link" href="/categories/notes/">notes</a></li><li><a class="category-link" href="/categories/project/">project</a></li><li><a class="category-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li><a class="category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</a></li><li><a class="category-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">归档</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2024/06/">June 2024</a></li><li><a class="archive-link" href="/archives/2024/03/">March 2024</a></li><li><a class="archive-link" href="/archives/2024/02/">February 2024</a></li><li><a class="archive-link" href="/archives/2024/01/">January 2024</a></li><li><a class="archive-link" href="/archives/2022/06/">June 2022</a></li><li><a class="archive-link" href="/archives/2022/04/">April 2022</a></li><li><a class="archive-link" href="/archives/2022/03/">March 2022</a></li><li><a class="archive-link" href="/archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="/archives/2021/09/">September 2021</a></li><li><a class="archive-link" href="/archives/2000/12/">December 2000</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        
		        <li>
		            <a href="/trajectory/" title="轨迹">
		                轨迹
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Ephemeral-rose" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="weixin" href="https://ephemeral-rose.github.io/info/" target="_blank" rel="noopener">
                            <i class="icon fa fa-weixin"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://s21.ax1x.com/2024/12/06/pATDlxH.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >JavaSE</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <hr>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h3><h4 id="x3D-x3D-Java的优点-x3D-x3D"><a href="#x3D-x3D-Java的优点-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java的优点&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java的优点&#x3D;&#x3D;</h4><p>简单、可移植、安全、并发</p>
<h4 id="x3D-x3D-JDK-JRE-JVM-x3D-x3D"><a href="#x3D-x3D-JDK-JRE-JVM-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;JDK JRE JVM&#x3D;&#x3D;"></a>&#x3D;&#x3D;JDK JRE JVM&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/jdk-install-config-6f6fdb4a-7a44-4e76-b4ea-71c070a5b220.png" alt="img" style="zoom:33%;" />

<p>JDK（Java Development Kit）是用于开发 Java 应用程序的软件环境。里面包含运行时环境（JRE）和其他 Java 开发所需的工具，比如说解释器（java）、编译器（javac）、文档生成器（javadoc）等等。</p>
<p>JRE（Java Runtime Environment）是用于运行 Java 应用程序的软件环境。也就是说，如果只想运行 Java 程序而不需要开发 Java 程序的话，只需要安装 JRE 就可以了。</p>
<p>JVM (Java Virtual Machine) ，也就是 Java 虚拟机，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等组成，屏蔽了不同操作系统（macOS、Windows、Linux）的差异性，使得 Java 能够“一次编译，到处运行”。</p>
<h4 id="x3D-x3D-源代码-字节码-java是编译还是解释-x3D-x3D"><a href="#x3D-x3D-源代码-字节码-java是编译还是解释-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;源代码\字节码 java是编译还是解释&#x3D;&#x3D;"></a>&#x3D;&#x3D;源代码\字节码 java是编译还是解释&#x3D;&#x3D;</h4><p>Java 的第一道工序是通过 javac 命令把 Java 源码编译成字节码。</p>
<p>之后，我们可以通过 java 命令运行字节码（比如说 <code>java Hello</code>），此时就有 2 种处理方式了。</p>
<ul>
<li>1、字节码由 JVM 逐条解释执行。</li>
<li>2、部分字节码可能由 JIT（即时编译编译为机器指令直接执行。</li>
</ul>
<p>①、逐条解释执行：</p>
<p>逐条解释执行是 Java 虚拟机的基本执行模式。在这种模式下，Java 虚拟机会逐条读取字节码文件中的指令，并将其解释为对应的底层操作。解释执行的优点是实现简单，启动速度较快，但由于每次执行都需要对字节码进行解释，因此执行效率相对较低。</p>
<p>总结一下逐条解释执行的特点：</p>
<ul>
<li>实现简单</li>
<li>启动速度较快</li>
<li>执行效率较低</li>
</ul>
<p>②、JIT 即时编译：</p>
<p>为了提高 Java 程序的执行效率，Java 虚拟机引入了即时编译（<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT，Just-In-Time Compilation</a>）技术。在 JIT 模式下，Java 虚拟机会在运行时将频繁执行的字节码编译为本地机器码，这样就可以直接在硬件上运行，而不需要再次解释。这样做的结果是显著提高了程序的执行速度。需要注意的是，JIT 编译器并不会编译所有的字节码，而是根据一定的策略，仅编译被频繁调用的代码段（热点代码）。</p>
<p>总结一下 JIT 即时编译的特点：</p>
<ul>
<li>提高执行效率</li>
<li>编译热点代码</li>
<li>动态优化</li>
</ul>
<p>实际上，现代 Java 虚拟机（如 HotSpot）通常会结合这两种执行方式，即解释执行和 JIT 即时编译。在程序运行初期，Java 虚拟机会采用解释执行，以减少启动时间。随着程序的运行，Java 虚拟机会识别出热点代码并使用 JIT 编译器将其编译为本地机器码，从而提高程序的执行效率。这种结合策略称为混合模式。</p>
<h4 id="x3D-x3D-Java数据类型-x3D-x3D"><a href="#x3D-x3D-Java数据类型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java数据类型&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java数据类型&#x3D;&#x3D;</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><img src="C:\Users\cxl\AppData\Roaming\Typora\typora-user-images\image-20241008092059093.png" alt="image-20241008092059093" style="zoom: 50%;" />

<h5 id="int和char转换"><a href="#int和char转换" class="headerlink" title="int和char转换"></a>int和char转换</h5><p>int-&gt;char</p>
<ul>
<li><p>强制类型转换</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> value_int <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> value_char  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> value_int<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>可以使用<code>Character.forDigit()</code>方法将整型 int 转换为字符 char，参数radix为基数，十进制为10，十六进制为16</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">char</span> value_char <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">forDigit</span><span class="token punctuation">(</span>value_int <span class="token punctuation">,</span> radix<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>可以使用int的包装器类型Integer的<code>toString()</code>方法+String的<code>charAt()</code>方法转成char</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">char</span> value_char <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>value_int<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>char-&gt;int</p>
<ul>
<li><p>直接赋值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>数字可以使用<code>Character.digit()</code>方法或使用<code>Character.digit()</code>方法或<code>- &#39;0&#39;</code>方法</p>
<p>字符’0’的编码值是48，字符’1’的编码值是49，依此类推，字符’9’的编码值是57</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">getNumericValue</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">digit</span><span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> c<span class="token operator">=</span> <span class="token char">'1'</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><h5 id="基本数据类型vs引用类型"><a href="#基本数据类型vs引用类型" class="headerlink" title="基本数据类型vs引用类型"></a>基本数据类型vs引用类型</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/core-grammar/nine-01.png" alt="img" style="zoom:33%;" />

<p>基本数据类型：</p>
<ul>
<li>变量名指向具体的数值</li>
<li>基本数据类型存储在栈上</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>变量名指向的是存储对象的内存地址，在栈上</li>
<li>内存地址指向的对象存储在堆上</li>
</ul>
<h4 id="x3D-x3D-数据类型转换-x3D-x3D"><a href="#x3D-x3D-数据类型转换-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;数据类型转换&#x3D;&#x3D;"></a>&#x3D;&#x3D;数据类型转换&#x3D;&#x3D;</h4><h5 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h5><p>自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：</p>
<ul>
<li>如果任一操作数是double类型，其他操作数将被转换为double类型</li>
<li>否则，如果任一操作数是float类型，其他操作数将被转换为float类型</li>
<li>否则，如果任一操作数是long类型，其他操作数将被转换为long类型</li>
<li>否则，所有操作数将被转换为int类型</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> <span class="token operator">-></span> <span class="token keyword">short</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token operator">-></span> <span class="token keyword">long</span> <span class="token operator">-></span> <span class="token keyword">float</span> <span class="token operator">-></span> <span class="token keyword">double</span>
<span class="token keyword">char</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token operator">-></span> <span class="token keyword">long</span> <span class="token operator">-></span> <span class="token keyword">float</span> <span class="token operator">-></span> <span class="token keyword">double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：</p>
<ul>
<li>将较大的数据类型转换为较小的数据类型。</li>
<li>将浮点数转换为整数。</li>
<li>将字符类型转换为数值类型。</li>
</ul>
<p>需要注意的是，强制类型转换可能会导致数据丢失或精度降低</p>
<h4 id="x3D-x3D-基本数据类型缓存池（IntegerCache）-x3D-x3D"><a href="#x3D-x3D-基本数据类型缓存池（IntegerCache）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基本数据类型缓存池（IntegerCache）&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本数据类型缓存池（IntegerCache）&#x3D;&#x3D;</h4><p>基本数据类型的包装类除了 Float和Double之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。</p>
<ul>
<li>Byte：-128~127，也就是所有的 byte 值</li>
<li>Short：-128~127</li>
<li>Long：-128~127</li>
<li>Character：\u0000 - \u007F</li>
<li>Boolean： true 和 false</li>
</ul>
<p>拿Integer来举例子，Integer 类内部中内置了256个Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。</p>
<p>在Java中，针对一些基本数据类型（如Integer、Long、Boolean等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序性能和节省内存开销。这些常用对象被缓存在一个固定范围内，超出这个范围的值会被重新创建新的对象。</p>
<p>使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。</p>
<h4 id="x3D-x3D-运算符-x3D-x3D"><a href="#x3D-x3D-运算符-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;运算符&#x3D;&#x3D;"></a>&#x3D;&#x3D;运算符&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/core-grammar/eleven-01.png" alt="img" style="zoom:25%;" />

<p>浮点数除以0的时候，结果为Infinity或者NaN</p>
<p>整数除以0的时候，会抛出异常</p>
<hr>
<h3 id="数组-amp-字符串"><a href="#数组-amp-字符串" class="headerlink" title="数组&amp;字符串"></a>数组&amp;字符串</h3><h4 id="x3D-x3D-数组-x3D-x3D"><a href="#x3D-x3D-数组-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;数组&#x3D;&#x3D;"></a>&#x3D;&#x3D;数组&#x3D;&#x3D;</h4><p>数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在Java中，索引是从0开始的。</p>
<p>数组也是一个对象，但Java中并未明确定义这样一个类</p>
<h5 id="数组的声明与初始化"><a href="#数组的声明与初始化" class="headerlink" title="数组的声明与初始化"></a>数组的声明与初始化</h5><h5 id="可变参数与数组"><a href="#可变参数与数组" class="headerlink" title="可变参数与数组"></a>可变参数与数组</h5><p>本质上，可变参数就是通过数组实现的</p>
<h5 id="数组与-List"><a href="#数组与-List" class="headerlink" title="数组与 List"></a>数组与 List</h5><p>把数组转成List</p>
<ul>
<li><p>遍历数组，创建List添加元素</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://javabetter.cn/common-tool/arrays.html">Arrays类</a>的<code>asList()</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> aList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>anArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Integer数组</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> aList1 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>stream流</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> aList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>anArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>Arrays.asList方法返回的ArrayList并不是<code>java.util.ArrayList</code>，它其实是Arrays类的一个内部类</p>
<p>如果需要添加元素或者删除元素的话，需要把它转成<code>java.util.ArrayList</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>anArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="数组的排序与查找"><a href="#数组的排序与查找" class="headerlink" title="数组的排序与查找"></a>数组的排序与查找</h5><p>如果想对数组进行排序的话，可以使用Arrays 类提供的<code>sort()</code>方法。</p>
<ul>
<li>基本数据类型按照升序排列</li>
<li>实现了Comparable接口的对象按照<code>compareTo()</code>的排序</li>
</ul>
<p>查找</p>
<ul>
<li>遍历</li>
<li>Arrays.binarySearch()</li>
</ul>
<h5 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h5><ul>
<li><p>遍历复制</p>
</li>
<li><p><code>Arrays.copyOfRange()</code>方法用来复制数组。底层调用的是<code>System.arraycopy()</code>方法，这个方法是一个native方法，它是用 C&#x2F;C++ 实现的，效率非常高</p>
</li>
</ul>
<h5 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h5><h4 id="x3D-x3D-二维数组-x3D-x3D"><a href="#x3D-x3D-二维数组-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;二维数组&#x3D;&#x3D;"></a>&#x3D;&#x3D;二维数组&#x3D;&#x3D;</h4><p>二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等</p>
<h4 id="x3D-x3D-数组打印-x3D-x3D"><a href="#x3D-x3D-数组打印-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;数组打印&#x3D;&#x3D;"></a>&#x3D;&#x3D;数组打印&#x3D;&#x3D;</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>cmowers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>cmowers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>cmowers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cmowers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cmowers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> cmowers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cmowers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">deepToString</span><span class="token punctuation">(</span>deepArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-字符串源码-x3D-x3D"><a href="#x3D-x3D-字符串源码-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字符串源码&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串源码&#x3D;&#x3D;</h4><h5 id="String-类的声明"><a href="#String-类的声明" class="headerlink" title="String 类的声明"></a>String 类的声明</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol>
<li>String类是final的，意味着它不能被子类继承</li>
<li>String类实现了Serializable接口，意味着它可以序列化</li>
<li>String类实现了Comparable接口,意味着最好不用‘&#x3D;&#x3D;’比较两个字符串是否相等，而应该用<code>compareTo()</code>方法比较</li>
<li>String 和 StringBuffer、StringBuilder一样，都实现了CharSequence接口</li>
</ol>
<h5 id="String底层为什么由char数组优化为byte数组"><a href="#String底层为什么由char数组优化为byte数组" class="headerlink" title="String底层为什么由char数组优化为byte数组"></a>String底层为什么由char数组优化为byte数组</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// jdk8</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// jdk11</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Stable</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>节省字符串占用的内存空间</strong>,内存占用减少GC次数也会减少</li>
<li>从<code>char[]</code>到<code>byte[]</code>，<strong>中文是两个字节，纯英文是一个字节，在此之前，中文是两个字节，英文也是两个字节</strong></li>
</ul>
<h5 id="String类的hashCode方法"><a href="#String类的hashCode方法" class="headerlink" title="String类的hashCode方法"></a>String类的hashCode方法</h5><p>每一个字符串都会有一个hash值，哈希值在很大概率是不会重复的，因此String很适合来作为HashMap的键值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 31倍hash法</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment">// 缓存字符串的哈希码</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span> <span class="token comment">// 从缓存中获取哈希码</span>
    <span class="token comment">// 如果哈希码未被计算过（即为 0）且字符串不为空，则计算哈希码</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// 获取字符串的字符数组</span>

        <span class="token comment">// 遍历字符串的每个字符来计算哈希码</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用 31 作为乘法因子</span>
        <span class="token punctuation">&#125;</span>
        hash <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment">// 缓存计算后的哈希码</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span> <span class="token comment">// 返回哈希码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="String类的substring方法"><a href="#String类的substring方法" class="headerlink" title="String类的substring方法"></a>String类的substring方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 检查起始索引是否小于 0，如果是，则抛出 StringIndexOutOfBoundsException 异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>beginIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 计算子字符串的长度</span>
    <span class="token keyword">int</span> subLen <span class="token operator">=</span> value<span class="token punctuation">.</span>length <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>
    <span class="token comment">// 检查子字符串长度是否为负数，如果是，则抛出 StringIndexOutOfBoundsException 异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subLen <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>subLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 如果起始索引为 0，则返回原字符串；否则，创建并返回新的字符串</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> beginIndex<span class="token punctuation">,</span> subLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="String类的indexOf方法"><a href="#String类的indexOf方法" class="headerlink" title="String类的indexOf方法"></a>String类的indexOf方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
 * 查找字符数组 target 在字符数组 source 中第一次出现的位置。
 * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，
 * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，
 * fromIndex 参数指定开始搜索的位置。
 * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），
 * 否则返回-1。
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> source<span class="token punctuation">,</span> <span class="token keyword">int</span> sourceOffset<span class="token punctuation">,</span> <span class="token keyword">int</span> sourceCount<span class="token punctuation">,</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> targetOffset<span class="token punctuation">,</span> <span class="token keyword">int</span> targetCount<span class="token punctuation">,</span>
        <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fromIndex <span class="token operator">>=</span> sourceCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>targetCount <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> sourceCount <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 如果开始搜索的位置小于0，则从0开始搜索</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fromIndex <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        fromIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 如果 target 数组为空，则直接返回开始搜索的位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>targetCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> fromIndex<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 查找 target 数组的第一个字符在 source 数组中的位置</span>
    <span class="token keyword">char</span> first <span class="token operator">=</span> target<span class="token punctuation">[</span>targetOffset<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> sourceOffset <span class="token operator">+</span> <span class="token punctuation">(</span>sourceCount <span class="token operator">-</span> targetCount<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 循环查找 target 数组在 source 数组中的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> sourceOffset <span class="token operator">+</span> fromIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">/* Look for first character. */</span>
        <span class="token comment">// 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">&lt;=</span> max <span class="token operator">&amp;&amp;</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Found first character, now look at the rest of v2 */</span>
        <span class="token comment">// 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> end <span class="token operator">=</span> j <span class="token operator">+</span> targetCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> targetOffset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> source<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    <span class="token operator">==</span> target<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* Found whole string. */</span>
                <span class="token keyword">return</span> i <span class="token operator">-</span> sourceOffset<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 没有找到 target 数组，则返回-1</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="String类的其他方法"><a href="#String类的其他方法" class="headerlink" title="String类的其他方法"></a>String类的其他方法</h5><ul>
<li><p><code>length()</code> 用于返回字符串长度</p>
</li>
<li><p><code>isEmpty()</code> 用于判断字符串是否为空</p>
</li>
<li><p><code>charAt()</code> 用于返回指定索引处的字符</p>
</li>
<li><p><code>valueOf()</code> 用于将其他类型的数据转换为字符串</p>
<ul>
<li><p>valueOf方法背后其实调用的是包装器类的toString方法，比如整数转为字符串调用的是Integer类的 toString方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>trim()</code>  去除字符串开头和结尾的空格</p>
</li>
<li><p><code>split()</code> 将字符串按照特定符号分隔成单词数组</p>
</li>
<li><p><code>concat()</code> 方法用于拼接字符串</p>
</li>
<li><p><code>replace()</code> 替换方法</p>
</li>
<li><p><code>intern()</code>  会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</p>
</li>
</ul>
<h4 id="x3D-x3D-为什么Java字符串不可变？-x3D-x3D"><a href="#x3D-x3D-为什么Java字符串不可变？-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;为什么Java字符串不可变？&#x3D;&#x3D;"></a>&#x3D;&#x3D;为什么Java字符串不可变？&#x3D;&#x3D;</h4><p>String 对象一旦被创建后就固定不变了，对 String对象的任何修改（截取、拼接、替换等）都不会影响到原来的字符串对象，都会生成新的字符串对象。<strong>原来的字符串对象并没有发生改变</strong></p>
<ol>
<li>可以保证String对象的安全性，避免被篡改。毕竟像密码这种隐私信息一般就是用字符串存储的</li>
<li>保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。在String类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。</li>
<li>可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个String对象，节省内存空间。</li>
</ol>
<h4 id="x3D-x3D-Java字符串双引号-vs-new对象声明-x3D-x3D"><a href="#x3D-x3D-Java字符串双引号-vs-new对象声明-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java字符串双引号 vs new对象声明&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java字符串双引号 vs new对象声明&#x3D;&#x3D;</h4><p>在JAVA语言中有基本类型和一种比较特殊的类型<code>String</code>。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。</p>
<p>8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊</p>
<ul>
<li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<h4 id="x3D-x3D-Java字符串常量池-x3D-x3D"><a href="#x3D-x3D-Java字符串常量池-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java字符串常量池&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java字符串常量池&#x3D;&#x3D;</h4><img src="C:\Users\cxl\AppData\Roaming\Typora\typora-user-images\image-20241008161820433.png" alt="image-20241008161820433" style="zoom: 50%;" />

<p>在 Java 中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。</p>
<p><strong>先在字符串常量池中创建对象，然后再在堆上创建</strong></p>
<h5 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h5><p>由于字符串的使用频率实在是太高了，所以Java虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。</p>
<h5 id="字符串常量池在内存中的位置"><a href="#字符串常量池在内存中的位置" class="headerlink" title="字符串常量池在内存中的位置"></a>字符串常量池在内存中的位置</h5><img src="https://cdn.tobebetterjavaer.com/stutymore/constant-pool-20240604095423.png" alt="字符串常量池的位置变化" style="zoom: 33%;" />

<ul>
<li><p>Java 7之前</p>
<p>​    <img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/string//constant-pool-ed6518ec-1d51-4718-ab8a-e1e2cda774bd.png" alt="img" style="zoom: 25%;" /></p>
<ul>
<li>在Java 7之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是Java堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。而Java堆是JVM中存储对象实例和数组的内存区域，也就是说，永久代是Java堆的一个子区域</li>
</ul>
</li>
<li><p>Java 7</p>
<p>​    <img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/string//constant-pool-f5231378-a442-421e-a470-8256da1715e8.png" alt="img" style="zoom:33%;" /></p>
<ul>
<li>永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。从Java 7开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</li>
</ul>
</li>
<li><p>Java 8</p>
<ul>
<li>到了Java 8，永久代（PermGen）被取消，由元空间（Metaspace）取代。元空间是一块本机内存区域，和JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。</li>
<li>元空间具有一些优点：<ul>
<li>不会导致OutOfMemoryError错误，因为元空间的大小可以动态调整。</li>
<li>元空间使用本机内存，而不是JVM堆内存，这可以避免堆内存的碎片化问题。</li>
<li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="方法区、永久代、元空间"><a href="#方法区、永久代、元空间" class="headerlink" title="方法区、永久代、元空间"></a>方法区、永久代、元空间</h5><ul>
<li>方法区是Java虚拟机规范中的一个概念</li>
<li>永久代和元空间是HotSpot虚拟机中对方法区的不同实现</li>
<li>永久代是放在运行时数据区中的，所以它的大小受到Java虚拟机本身大小的限制</li>
<li>元空间是直接放在内存中的，所以只受本机可用内存的限制</li>
</ul>
<h5 id="详解String-intern-方法"><a href="#详解String-intern-方法" class="headerlink" title="详解String.intern()方法"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/string/intern.html">详解String.intern()方法</a></h5><h4 id="x3D-x3D-StringBuilder和StringBuffer-x3D-x3D"><a href="#x3D-x3D-StringBuilder和StringBuffer-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;StringBuilder和StringBuffer&#x3D;&#x3D;"></a>&#x3D;&#x3D;StringBuilder和StringBuffer&#x3D;&#x3D;</h4><p>StringBuffer操作字符串的方法加了<code>synchronized</code> 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以如果在非多线程环境下，执行效率就会比较低，因为加了没必要的锁。</p>
<p>StringBuilder在单线程环境下使用，效率高。如果在多线程环境下修改字符串，可以使用<code>ThreadLocal</code>来避免多线程冲突</p>
<h5 id="StringBuilder的内部实现"><a href="#StringBuilder的内部实现" class="headerlink" title="StringBuilder的内部实现"></a>StringBuilder的内部实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// StringBuilder 的 toString 方法。count 是一个 int 类型的变量，表示字符序列的长度。</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// value 是一个 char 类型的数组</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>

<span class="token comment">//  StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串</span>
<span class="token keyword">public</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。</span>
<span class="token keyword">public</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 不够用了，扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">expandCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">expandCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 扩容策略：新容量为旧容量的两倍加上 2</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> value<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果新容量小于指定的最小容量，则新容量为指定的最小容量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minimumCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minimumCapacity<span class="token punctuation">;</span>
    <span class="token comment">// 如果新容量小于 0，则新容量为 Integer.MAX_VALUE</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newCapacity <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 将字符序列的容量扩容到新容量的大小</span>
    value <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="StringBuilder的reverse方法"><a href="#StringBuilder的reverse方法" class="headerlink" title="StringBuilder的reverse方法"></a>StringBuilder的reverse方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 字符序列的最后一个字符的索引</span>
    <span class="token comment">// 遍历字符串的前半部分</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> n <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token comment">// 计算相对于 j 对称的字符的索引</span>
        <span class="token keyword">char</span> cj <span class="token operator">=</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前位置的字符</span>
        <span class="token keyword">char</span> ck <span class="token operator">=</span> value<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取对称位置的字符</span>
        value<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ck<span class="token punctuation">;</span> <span class="token comment">// 交换字符</span>
        value<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> cj<span class="token punctuation">;</span> <span class="token comment">// 交换字符</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 返回反转后的字符串构建器对象</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-字符串相等判断-x3D-x3D"><a href="#x3D-x3D-字符串相等判断-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字符串相等判断&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串相等判断&#x3D;&#x3D;</h4><ul>
<li><code>==</code>操作符 用于比较地址</li>
<li><code>.equals()</code>方法 用于比较内容</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Object的equals 源码</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>Object 类的<code>.equals()</code>方法默认采用的是<code>==</code>操作符进行比较。假如子类没有重写该方法的话，那么<code>==</code>操作符和 <code>.equals()</code>方法完全一样</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// String类的equals源码</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> aString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> aString<span class="token punctuation">.</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">StringLatin1</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> aString<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                    <span class="token operator">:</span> <span class="token class-name">StringUTF16</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> aString<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>字符串相等判断其他方法</p>
<ul>
<li><p>Objects.equals() </p>
<ul>
<li>&#x3D;&#x3D;不需要判空&#x3D;&#x3D;</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> a<span class="token punctuation">,</span> <span class="token class-name">Object</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 直接使用 a.equals(b)，则需要在调用之前对a进行判空，否则可能抛出空指针 java.lang.NullPointerException</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>String 类的<code>.contentEquals()</code> </p>
<ul>
<li>&#x3D;&#x3D;可以将字符串与任何字符序列（StringBuffer、StringBuilder、String、CharSequence）比较&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-字符串拼接-x3D-x3D"><a href="#x3D-x3D-字符串拼接-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字符串拼接&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串拼接&#x3D;&#x3D;</h4><ul>
<li>+号操作符<ul>
<li>本质上是new StringBuilder对象进行append操作</li>
</ul>
</li>
<li>StringBuilder.append()<ol>
<li>判空</li>
<li>获取长度</li>
<li>判断扩容</li>
<li>拼接复制</li>
<li>更新数组长度count</li>
</ol>
</li>
<li>String.concat()<ul>
<li>判断待拼接长度是否为0，是返回当前字符串</li>
<li>复制当前字符串</li>
<li>复制待拼接字符串，返回新字符串对象</li>
</ul>
</li>
<li>String.join()<ul>
<li>第一个参数为字符串连接符</li>
<li>新建一个StringJoiner对象，通过for-each循环把可变参数添加进来，最后调用<code>toString()</code>返回String</li>
</ul>
</li>
<li>StringUtils.join()<ul>
<li>内部使用的仍然是 StringBuilder。该方法不用担心 NullPointerException</li>
</ul>
</li>
</ul>
<p><code>concat()</code>方法在遇到字符串为<code>null</code>的时候，会抛出<code>NullPointerException</code></p>
<p>而<code>“+”</code>号操作符会把 null 当做是<code>“null”</code>字符串来处理。</p>
<p>如果拼接的字符串是一个<code>空字符串（&quot;&quot;）</code>，那么concat的效率要更高一点,毕竟不需要<code>new StringBuilder</code>对象。</p>
<p>如果拼接的字符串非常多，<code>concat()</code>的效率就会下降，因为创建的字符串对象越来越多</p>
<h4 id="x3D-x3D-字符串拆分-x3D-x3D"><a href="#x3D-x3D-字符串拆分-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字符串拆分&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串拆分&#x3D;&#x3D;</h4><hr>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="x3D-x3D-类和对象-x3D-x3D"><a href="#x3D-x3D-类和对象-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;类和对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;类和对象&#x3D;&#x3D;</h4><h5 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h5><ul>
<li>状态+行为+标识&#x3D;对象，每个对象在内存中都会有一个唯一的地址</li>
<li>对象具有接口</li>
<li>访问权限修饰符</li>
<li>组合代表的关系是has-a的关系</li>
<li>继承是is-a或is-like-a的关系</li>
</ul>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>一个类可以包含：</p>
<ul>
<li>字段（Filed）</li>
<li>方法（Method）</li>
<li>构造方法（Constructor）</li>
</ul>
<p>成员变量——在类内部但在方法外部，方法内部的叫临时变量。</p>
<p>成员变量有时也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化后，字段才会获取到内存，这也正是它被称作“实例”变量的原因</p>
<h5 id="new一个对象"><a href="#new一个对象" class="headerlink" title="new一个对象"></a>new一个对象</h5><p>所有<strong>对象</strong>在创建的时候都会在<strong>堆内存中分配空间</strong></p>
<p>匿名对象意味着没有引用变量，它只能在创建的时候被使用一次</p>
<h5 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h5><h5 id="关于Object类"><a href="#关于Object类" class="headerlink" title="关于Object类"></a>关于Object类</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-21.png" alt="三分恶面渣逆袭：Object类的方法" style="zoom: 50%;" />

<h4 id="x3D-x3D-包-x3D-x3D"><a href="#x3D-x3D-包-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;包&#x3D;&#x3D;"></a>&#x3D;&#x3D;包&#x3D;&#x3D;</h4><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系</p>
<p>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p>
<p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入</p>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>包的作用域</p>
<h5 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h5><ul>
<li>使用完整类名</li>
<li><code>import</code>语句</li>
<li><code>import static</code>语法，可以导入一个类的静态字段和静态方法</li>
</ul>
<p>Java 编译器最终编译出的<code>.class</code>文件只使用 <em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code></li>
</ul>
</li>
</ul>
<p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</p>
<p>默认自动<code>import java.lang.*</code></p>
<h5 id="包的最佳实践"><a href="#包的最佳实践" class="headerlink" title="包的最佳实践"></a>包的最佳实践</h5><ul>
<li>使用倒置的域名来确保唯一性</li>
</ul>
<h4 id="x3D-x3D-变量-x3D-x3D"><a href="#x3D-x3D-变量-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;变量&#x3D;&#x3D;"></a>&#x3D;&#x3D;变量&#x3D;&#x3D;</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li>在方法体内声明的变量，只能在该方法内使用</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。该变量只能通过类的实例（对象）来访问</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁</li>
<li>成员变量可以声明在使用前或者使用后</li>
<li>访问修饰符可以修饰成员变量</li>
<li>成员变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null</li>
</ul>
<h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><ul>
<li>通过static关键字声明的变量被称为静态变量（类变量），它可以直接被类访问</li>
<li>无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝</li>
<li>静态变量在程序开始时创建，在程序结束时销毁</li>
<li>静态变量储存在静态存储区</li>
<li>静态变量还可以在静态语句块中初始化</li>
</ul>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><h4 id="x3D-x3D-方法-x3D-x3D"><a href="#x3D-x3D-方法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;方法&#x3D;&#x3D;"></a>&#x3D;&#x3D;方法&#x3D;&#x3D;</h4><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/17-01.png" alt="img" style="zoom:50%;" />

<ul>
<li><p><strong>访问权限</strong>：指定方法的可见性。Java提供了四种访问权限修饰符</p>
<ul>
<li><p>public：该方法可以被所有类访问。</p>
</li>
<li><p>private：该方法只能在定义它的类中访问。</p>
</li>
<li><p>protected：该方法可以被同一个包中的类，或者不同包中的子类访问。</p>
</li>
<li><p>default：package-private 的，意味着该方法只能被同一个包中的类可见。</p>
</li>
</ul>
</li>
<li><p><strong>返回类型</strong>：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用void关键字。</p>
</li>
<li><p><strong>方法签名</strong>：每一个方法都有一个签名，包括方法名和参数。</p>
<ul>
<li><strong>方法名</strong></li>
<li><strong>参数</strong>：参数类型和参数名</li>
</ul>
</li>
<li><p><strong>方法体</strong></p>
</li>
</ul>
<h5 id="实例方法-静态方法"><a href="#实例方法-静态方法" class="headerlink" title="实例方法 静态方法"></a>实例方法 静态方法</h5><p>没有使用static关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象</p>
<p>有static关键字修饰的方法就叫做静态方法</p>
<h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用abstract关键字创建抽象方法和抽象类。当一个类继承了抽象类后，就必须重写抽象方法</p>
<h4 id="x3D-x3D-可变参数-x3D-x3D"><a href="#x3D-x3D-可变参数-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;可变参数&#x3D;&#x3D;"></a>&#x3D;&#x3D;可变参数&#x3D;&#x3D;</h4><p>可变参数是Java 1.5的时候引入的功能，它允许方法使用任意多个、类型相同（<code>is-a</code>）的值作为参数</p>
<p>尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位</p>
<p><strong>使用可变参数时，实际上先创建一个数组，该数组大小是可变参数的个数，然后将参数放入数组中，将数组传递给被调用方法</strong>。</p>
<h4 id="x3D-x3D-native方法-x3D-x3D"><a href="#x3D-x3D-native方法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;native方法&#x3D;&#x3D;"></a>&#x3D;&#x3D;native方法&#x3D;&#x3D;</h4><p>用<code>native</code>关键词修饰的方法，多数情况下不需要用Java语言实现</p>
<h5 id="JNI：Java-Native-Interface"><a href="#JNI：Java-Native-Interface" class="headerlink" title="JNI：Java Native Interface"></a>JNI：Java Native Interface</h5><p>场景</p>
<ul>
<li>标准的Java类库不支持。</li>
<li>已经用另一种语言编写了一个类库，用Java代码调用</li>
<li>某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写</li>
</ul>
<p>通过JNI，我们就可以通过Java程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过JNI提供的相应原生接口调用Java应用系统内部实现的功能</p>
<p>JNI的缺点：</p>
<ul>
<li>程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</li>
<li>程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，应该让本地方法集中在少数几个类当中。这样就降低了Java和C&#x2F;C++之间的耦合性</li>
</ul>
<h5 id="JNI调用C的流程图"><a href="#JNI调用C的流程图" class="headerlink" title="JNI调用C的流程图"></a>JNI调用C的流程图</h5><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/oo/native-method-6673cf73-c4dd-4434-b821-0d705f756a73.png" alt="img" style="zoom:33%;" />

<h5 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h5><p>native语法：</p>
<ul>
<li>修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</li>
<li>不能用abstract修饰，也没有方法体，也没有左右大括号。</li>
<li>返回值可以是任意类型</li>
</ul>
<h4 id="x3D-x3D-构造方法-x3D-x3D"><a href="#x3D-x3D-构造方法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;构造方法&#x3D;&#x3D;"></a>&#x3D;&#x3D;构造方法&#x3D;&#x3D;</h4><p>构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用<code>new</code>关键字创建对象的时候，构造方法至少会被调用一次</p>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul>
<li>构造方法的名字必须和类名一样；</li>
<li>构造方法没有返回类型，包括 void；</li>
<li>构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）<ul>
<li>由于构造方法不能被子类继承，所以用final和abstract关键字修饰没有意义</li>
<li>构造方法用于初始化一个对象，所以用static关键字修饰没有意义</li>
<li>多个线程不会同时创建内存地址相同的同一个对象，所以用synchronized关键字修饰没有必要</li>
</ul>
</li>
</ul>
<h5 id="构造方法和方法的区别"><a href="#构造方法和方法的区别" class="headerlink" title="构造方法和方法的区别"></a>构造方法和方法的区别</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/18-02.png" alt="img" style="zoom: 50%;" />

<h5 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h5><ul>
<li>通过构造方法</li>
<li>通过对象的值</li>
<li>通过Object类的<code>clone()</code>方法<ul>
<li>通过<code>clone()</code>方法复制对象的时候，必须先实现Cloneable接口的<code>clone()</code>方法，然后再调用<code>clone()</code>方法</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-访问权限修饰符-x3D-x3D"><a href="#x3D-x3D-访问权限修饰符-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;访问权限修饰符&#x3D;&#x3D;"></a>&#x3D;&#x3D;访问权限修饰符&#x3D;&#x3D;</h4><p>在 Java 中，提供了四种访问权限控制：</p>
<ul>
<li>默认访问权限（包访问权限）</li>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>类只可以用默认访问权限和public修饰。但变量和方法则都可以修饰。</p>
<p>Java中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；</p>
<p>对于一个Java源代码文件，如果存在public类的话，只能有一个public类，且此时源代码文件的名称必须和public类的名称完全相同。如果存在其他类，这些类在包外是不可见的。如果源代码文件没有public类，则源代码文件的名称可以随意命名。</p>
<h4 id="x3D-x3D-代码初始化块-x3D-x3D"><a href="#x3D-x3D-代码初始化块-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;代码初始化块&#x3D;&#x3D;"></a>&#x3D;&#x3D;代码初始化块&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/22-01.png" alt="img" style="zoom:33%;" />

<ul>
<li>类实例化的时候执行代码初始化块；</li>
<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>
<li>代码初始化块里的执行顺序是从前到后的。</li>
<li>在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。显示：父初始化&gt;父构造&gt;子初始化&gt;子构造</li>
<li>静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行</li>
</ul>
<h4 id="x3D-x3D-抽象类-x3D-x3D"><a href="#x3D-x3D-抽象类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;抽象类&#x3D;&#x3D;"></a>&#x3D;&#x3D;抽象类&#x3D;&#x3D;</h4><p>抽象类命名规范 - 抽象类命名要使用Abstract或Base开头</p>
<p>抽象类不能实例化</p>
<p>抽象类中的抽象方法没有方法体</p>
<p>如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类</p>
<p>抽象类中既可以定义抽象方法，也可以定义普通方法</p>
<p>抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类</p>
<h5 id="抽象类使用场景"><a href="#抽象类使用场景" class="headerlink" title="抽象类使用场景"></a>抽象类使用场景</h5><ul>
<li>一些通用的功能被多个子类复用的时候</li>
<li>需要在抽象类中定义好API，然后在子类中扩展实现的时候就可以使用抽象类</li>
</ul>
<h4 id="x3D-x3D-接口-x3D-x3D"><a href="#x3D-x3D-接口-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;接口&#x3D;&#x3D;"></a>&#x3D;&#x3D;接口&#x3D;&#x3D;</h4><ul>
<li><p>接口是隐式抽象的，所以声明时没有必要使用 <code>abstract</code> 关键字；</p>
</li>
<li><p>接口的每个方法都是隐式抽象的，所以同样不需要使用<code>abstract</code>关键字；</p>
</li>
<li><p>接口中的方法都是隐式 <code>public</code> 的</p>
</li>
<li><p>接口通过interface关键字来定义，它可以包含一些常量和方法</p>
</li>
<li><p><strong>接口中定义的变量会在编译的时候自动加上<code>public static final</code>修饰符</strong></p>
</li>
<li><p><strong>没有使用<code>private</code>、<code>default</code>或者<code>static</code>关键字修饰的方法是隐式抽象的</strong></p>
</li>
<li><p><strong>从Java 8开始，接口中允许有静态方法</strong>。静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用</p>
</li>
<li><p>从Java 8开始<strong>接口中允许定义<code>default</code>方法</strong>。始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体</p>
</li>
<li><p><strong>接口不允许直接实例化</strong></p>
</li>
<li><p><strong>接口可以是空的</strong></p>
</li>
<li><p><strong>不要在定义接口的时候使用final关键字</strong></p>
</li>
<li><p><strong>接口的抽象方法不能是private、protected或者final</strong></p>
</li>
<li><p><strong>接口的变量是隐式<code>public static final</code>（常量）</strong>，所以其值无法改变</p>
</li>
</ul>
<h5 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h5><ul>
<li><strong>使某些实现类具有我们想要的功能</strong></li>
<li><strong>Java原则上只支持单一继承，但通过接口可以实现多重继承的目的</strong></li>
<li><strong>实现多态</strong><ul>
<li>多态存在的3个前提<ul>
<li>要有继承关系</li>
<li>子类要重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="接口的三种模式"><a href="#接口的三种模式" class="headerlink" title="接口的三种模式"></a>接口的三种模式</h5><ul>
<li><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/interface.html#_1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a></h4><ul>
<li>策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变</li>
</ul>
</li>
<li><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/interface.html#_2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></h4><ul>
<li>适配器模式的思想是，针对调用者的需求对原有的接口进行转接。如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。</li>
</ul>
</li>
<li><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/oo/interface.html#_3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a></h4></li>
</ul>
<h5 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h5><ul>
<li><p>语法层面上</p>
<ul>
<li><p>抽象类可以包含具体方法的实现；</p>
<p>在接口中，方法默认是public abstract的，但从Java 8开始，接口也可以包含有实现的默认方法和静态方法。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
</li>
<li><p>接口中不能含有静态代码块，而抽象类可以有静态代码块；</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>
</li>
</ul>
</li>
<li><p>设计层面上</p>
<ul>
<li><p>抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种<code>is-a</code>的关系。</p>
<p>而接口是对行为的抽象。接口和类之间并没有很强的关联关系</p>
</li>
<li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
</li>
<li><p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计</p>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-内部类-x3D-x3D"><a href="#x3D-x3D-内部类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;内部类&#x3D;&#x3D;"></a>&#x3D;&#x3D;内部类&#x3D;&#x3D;</h4><p>可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类</p>
<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>内部类可以随意访问外部类的成员，但外部类想要访问内部类的成员，必须先创建一个成员内部类的对象，再通过对象访问</p>
<p>如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的</p>
<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便</p>
<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内</p>
<p>局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就好像一个方法的参数一样，用完就没</p>
<p>匿名内部类是唯一一种没有构造方法的类，就像是直接通过new关键字创建出来的一个对象。名字是<code>借用的外部类$1</code> </p>
<p>匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>静态内部类和成员内部类类似，只是多了一个static关键字</p>
<p>由于static关键字的存在，静态内部类是不允许访问外部类中非static的变量和方法的</p>
<h5 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h5><ul>
<li>每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响.可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</li>
<li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li>
<li>4、内部类并没有令人迷惑的“is-a”关系，内部类就是一个独立的实体。</li>
<li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<h4 id="x3D-x3D-封装继承多态-x3D-x3D"><a href="#x3D-x3D-封装继承多态-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;封装继承多态&#x3D;&#x3D;"></a>&#x3D;&#x3D;封装继承多态&#x3D;&#x3D;</h4><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p>
<p>使用封装有4大好处：</p>
<ul>
<li>1、良好的封装能够减少耦合。</li>
<li>2、类内部的结构可以自由修改。</li>
<li>3、可以对成员进行更精确的控制。</li>
<li>4、隐藏信息，实现细节。</li>
</ul>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><strong>子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法</strong></p>
<p><strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见</strong>。</p>
<p>&#x3D;&#x3D;继承的分类&#x3D;&#x3D;</p>
<ul>
<li><strong>单继承</strong></li>
<li><strong>多继承</strong>（Java虽然不支持多继承，但是Java有三种实现多继承效果的方式）<ul>
<li>内部类 - 可以继承一个与外部类无关的类，保证了内部类的独立性 -</li>
<li>多层继承 - 子类拥有所有被继承类的属性和方法</li>
<li>实现接口 - 满足多继承使用需求的最好方式</li>
</ul>
</li>
</ul>
<p>继承的主要内容就是子类继承父类，并重写父类的方法</p>
<p>子类继承父类就拥有父类的<strong>非私有的</strong>属性和方法。<strong>父类的构造方法不能被继承</strong>，<strong>子类的构造过程必须调用其父类的构造方法</strong></p>
<p>Java虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为<strong>内存叠加</strong></p>
<p><strong>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法</strong></p>
<p>&#x3D;&#x3D;继承与修饰符&#x3D;&#x3D;</p>
<ul>
<li>访问修饰符<ul>
<li>Java子类重写继承方法时不可以降低访问权限<strong>，</strong>子类继承父类的访问修饰符作用域不能比父类小，需要更加开放</li>
<li>子类方法的异常不可大于父类对应方法抛出异常范围，<strong>子类抛出的异常必须是父类异常或父类异常的子异常</strong></li>
</ul>
</li>
<li>非访问修饰符</li>
</ul>
<p>&#x3D;&#x3D;Object类和转型&#x3D;&#x3D;</p>
<p>如果一个类没有显式声明它的父类（即没有写 extends xx），那么默认这个类的父类就是Object类，任何类都可以使用 Object类的方法，创建的类也可和Object进行向上、向下转型</p>
<p>&#x3D;&#x3D;子父类初始化顺序&#x3D;&#x3D;</p>
<p>在Java继承中，父子类初始化先后顺序为：</p>
<ol>
<li>父类中静态成员变量和静态代码块</li>
<li>子类中静态成员变量和静态代码块</li>
<li>父类中普通成员变量和代码块，父类的构造方法</li>
<li>子类中普通成员变量和代码块，子类的构造方法</li>
</ol>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态</p>
<p>多态的前提条件有三个：</p>
<ul>
<li>子类继承父类</li>
<li>子类重写父类的方法</li>
<li>父类引用指向子类的对象</li>
</ul>
<p>在运行时根据对象的类型进行后期绑定.编译器在编译阶段并不知道对象的类型，但是Java方法调用机制能找到正确的方法体，然后执行，得到正确的结果</p>
<h4 id="x3D-x3D-this和super-x3D-x3D"><a href="#x3D-x3D-this和super-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;this和super&#x3D;&#x3D;"></a>&#x3D;&#x3D;this和super&#x3D;&#x3D;</h4><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><ul>
<li>作为引用变量，指向当前对象</li>
<li>调用当前类的方法</li>
<li><code>this()</code>可以调用当前类的构造方法.<code>this()</code> 必须放在构造方法的第一行</li>
<li>this可以作为参数在方法中传递</li>
<li>this可以作为参数在构造方法中传递</li>
<li>this可以作为方法的返回值，返回当前类的对象</li>
</ul>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><ul>
<li>指向父类对象；</li>
<li>调用父类的方法；</li>
<li><code>super()</code>可以调用父类的构造方法。在默认情况下，<code>super()</code>是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类即使不使用<code>super()</code>主动调用父类的构造方法，父类的构造方法仍然会先执行</li>
</ul>
<h4 id="x3D-x3D-static-x3D-x3D"><a href="#x3D-x3D-static-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;static&#x3D;&#x3D;"></a>&#x3D;&#x3D;static&#x3D;&#x3D;</h4><p><strong>方便在没有创建对象的情况下进行调用</strong></p>
<h4 id="x3D-x3D-final-x3D-x3D"><a href="#x3D-x3D-final-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;final&#x3D;&#x3D;"></a>&#x3D;&#x3D;final&#x3D;&#x3D;</h4><h4 id="x3D-x3D-instanceof-x3D-x3D"><a href="#x3D-x3D-instanceof-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;instanceof&#x3D;&#x3D;"></a>&#x3D;&#x3D;instanceof&#x3D;&#x3D;</h4><h4 id="x3D-x3D-不可变对象-x3D-x3D"><a href="#x3D-x3D-不可变对象-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;不可变对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;不可变对象&#x3D;&#x3D;</h4><h5 id="什么是不可变类"><a href="#什么是不可变类" class="headerlink" title="什么是不可变类"></a>什么是不可变类</h5><p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何setter方法供外部类去修改。</p>
<h5 id="常见的不可变类-String类"><a href="#常见的不可变类-String类" class="headerlink" title="常见的不可变类 - String类"></a>常见的不可变类 - String类</h5><ul>
<li>常量池的需要。减少JVM的内存开销，提高效率</li>
<li>hashCode需要。String不可变作为哈希值，确保多次调用只返回同一个值</li>
<li>线程安全需要。可以在多个线程之间共享，不需要同步处理</li>
</ul>
<h5 id="不可变类必须满足的4个条件"><a href="#不可变类必须满足的4个条件" class="headerlink" title="不可变类必须满足的4个条件"></a>不可变类必须满足的4个条件</h5><ul>
<li><p><strong>确保类是final的</strong>，不允许被其他类继承*。</p>
</li>
<li><p><strong>确保所有的成员变量（字段）是final的</strong>，只能在构造方法中初始化值，并且不会在随后被修改。</p>
</li>
<li><p><strong>不要提供任何setter方法</strong>。</p>
</li>
<li><p><strong>如果要修改类的状态，必须返回一个新的对象</strong>。</p>
<p>如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是可变对象的副本</p>
</li>
</ul>
<h4 id="x3D-x3D-方法重写和方法重载-x3D-x3D"><a href="#x3D-x3D-方法重写和方法重载-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;方法重写和方法重载&#x3D;&#x3D;"></a>&#x3D;&#x3D;方法重写和方法重载&#x3D;&#x3D;</h4><h5 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写  Override"></a>方法重写  Override</h5><ul>
<li><p>子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同）</p>
</li>
<li><p>重写时应当遵守的12条规则</p>
<ul>
<li><strong>只能重写继承过来的方法</strong></li>
<li><strong>final、static的方法不能被重写</strong></li>
<li><strong>重写的方法必须有相同的参数列表</strong></li>
<li><strong>重写的方法必须返回相同的类型</strong></li>
<li><strong>重写的方法不能使用限制等级更严格的权限修饰符</strong></li>
<li><strong>重写后的方法不能抛出比父类中更高级别的异常</strong></li>
<li><strong>可以在子类中通过super关键字来调用父类中被重写的方法</strong></li>
<li><strong>构造方法不能被重写</strong></li>
<li><strong>如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写</strong></li>
<li><strong>synchronized关键字对重写规则没有任何影响</strong></li>
<li><strong>strictfp关键字对重写规则没有任何影响</strong></li>
</ul>
</li>
</ul>
<h5 id="方法重载-Overloading"><a href="#方法重载-Overloading" class="headerlink" title="方法重载 Overloading"></a>方法重载 Overloading</h5><ul>
<li><p>一个类有多个名字相同但参数个数不同的方法</p>
</li>
<li><p><code>main()</code>方法可以重载，但Java虚拟机在运行的时候只会调用String[]的main()方法</p>
</li>
<li><p>由于可以通过改变参数类型的方式实现方法重载，当传递的参数没有找到匹配的方法时，就会发生隐式类型转换</p>
</li>
</ul>
<h4 id="x3D-x3D-注解-x3D-x3D"><a href="#x3D-x3D-注解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;注解&#x3D;&#x3D;"></a>&#x3D;&#x3D;注解&#x3D;&#x3D;</h4><p>注解（Annotation）是在Java 1.5时引入的概念，同class和interface一样，也属于一种类型。注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作</p>
<h5 id="注解的生命周期"><a href="#注解的生命周期" class="headerlink" title="注解的生命周期"></a>注解的生命周期</h5><ul>
<li>注解的生命周期有3种策略，定义在RetentionPolicy枚举中<ul>
<li>SOURCE  - 在源文件中有效，被编译器丢弃</li>
<li>CLASS   - 在编译器生成的字节码文件中有效，但在运行时会被处理类文件的JVM丢弃。</li>
<li>RUNTIME - 在运行时有效。注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码</li>
</ul>
</li>
</ul>
<h5 id="注解的类型"><a href="#注解的类型" class="headerlink" title="注解的类型"></a>注解的类型</h5><ul>
<li><p>注解的类型一共有11种，定义在ElementType枚举中</p>
<ul>
<li><p>TYPE      - 用于类、接口、注解、枚举</p>
</li>
<li><p>FIELD     - 用于字段（类的成员变量），或者枚举常量</p>
</li>
<li><p>METHOD    - 用于方法</p>
</li>
<li><p>PARAMETER - 用于普通方法或者构造方法的参数</p>
</li>
<li><p>CONSTRUCTOR     - 用于构造方法</p>
</li>
<li><p>LOCAL_VARIABLE  - 用于变量</p>
</li>
<li><p>ANNOTATION_TYPE - 用于注解</p>
</li>
<li><p>PACKAGE  - 用于包</p>
</li>
<li><p>TYPE_PARAMETER - 用于泛型参数</p>
</li>
<li><p>TYPE_USE - 用于声明语句、泛型或者强制转换语句中的类型</p>
</li>
<li><p>MODULE   - 用于模块</p>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-枚举enum-x3D-x3D"><a href="#x3D-x3D-枚举enum-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;枚举enum&#x3D;&#x3D;"></a>&#x3D;&#x3D;枚举enum&#x3D;&#x3D;</h4><p>枚举（enum）是Java 1.5时引入的关键字。它表示一种特殊类型的类，继承自java.lang.Enum</p>
<h5 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h5><ul>
<li>一个专门针对枚举类型的Set接口的实现类</li>
<li>抽象类，创建时不能使用new关键字,提供许多静态工厂方法</li>
<li><code>noneOf()</code>静态工厂方法创建了一个空的枚举类型的EnumSet</li>
<li><code>allOf()</code>静态工厂方法创建了一个包含所有枚举类型的EnumSet</li>
<li>可以使用Set的一些方法</li>
</ul>
<h5 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h5><ul>
<li>一个专门针对枚举类型的Map接口的实现类，它可以将枚举常量作为键来使用</li>
<li>非抽象类，创建时可以使用new关键字</li>
<li>EnumMap的效率比HashMap还要高，可以直接通过数组下标（枚举的ordinal值）访问到元素</li>
<li>可以使用Map的一些方法</li>
</ul>
<h5 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h5><ul>
<li><p>单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为这个类只有一个对象，所以就不能再使用<code>new</code>关键字来创建新的对象</p>
</li>
<li><p>传统实现 -  volatile、synchronized关键字</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>  
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span> 
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        	<span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
            	singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        	<span class="token punctuation">&#125;</span>  
        <span class="token punctuation">&#125;</span>  
    <span class="token punctuation">&#125;</span>  
    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>枚举实现 - &#x3D;&#x3D;枚举默认实现了Serializable接口，因此 Java 虚拟机可以保证该类为单例&#x3D;&#x3D; </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">EasySingleton</span><span class="token punctuation">&#123;</span>
    INSTANCE<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h3 id="集合框架（容器）"><a href="#集合框架（容器）" class="headerlink" title="集合框架（容器）"></a>集合框架（容器）</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png" alt="img"></p>
<p>Java集合框架可以分为两条大的支线：</p>
<p>①、Collection，主要由 List、Set、Queue 组成：</p>
<ul>
<li>List代表有序、可重复的集合。典型代表就是封装了动态数组的<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/arraylist.html">ArrayList</a>和封装了链表的<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a>；</li>
<li>Set代表无序、不可重复的集合。典型代表就是HashSet和TreeSet；</li>
<li>Queue代表队列。典型代表就是双端队列<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/arraydeque.html">ArrayDeque</a>，以及优先级队列<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/PriorityQueue.html">PriorityQueue</a>。</li>
</ul>
<p>②、Map，代表键值对的集合，典型代表就是HashMap</p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作</p>
<ul>
<li><p><strong>ArrayList</strong></p>
<ul>
<li>ArrayList是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</li>
<li>从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；</li>
<li>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低</li>
</ul>
</li>
<li><p><strong>LinkedList</strong></p>
<ul>
<li>LinkedList是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；</li>
<li>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像ArrayList那样需要复制和移动数组元素；</li>
<li>因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比ArrayList多一些</li>
</ul>
</li>
<li><h4 id="Vector和Stack"><a href="#Vector和Stack" class="headerlink" title="Vector和Stack"></a><strong>Vector和Stack</strong></h4><ul>
<li>Vecotr由动态数组实现，线程安全。被ArrayList取代</li>
<li>Stack是Vector的一个子类，追加实现先进后出，由动态数组实现，线程安全。被ArrayDeque取代</li>
</ul>
</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作</p>
<ul>
<li><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li>由HashMap实现，值由一个固定的Object对象填充，而键用于操作</li>
<li>主要用于去重</li>
</ul>
</li>
<li><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li>继承自HashSet，由LinkedHashMap实现</li>
<li>一种基于哈希表实现的Set接口，它继承自HashSet，并且使用链表维护了元素的插入顺序。因此，它既具有 HashSet的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序</li>
</ul>
</li>
<li><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li>由TreeMap实现</li>
<li>一种基于红黑树实现的有序集合，它实现了SortedSet接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序</li>
<li>TreeSet不允许插入null元素，否则会抛出NullPointerException异常</li>
</ul>
</li>
</ul>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>Queue，队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列尾部，访问元素返回队列头部</p>
<ul>
<li><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><ul>
<li>一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。</li>
<li>head指向队首的第一个有效的元素，tail指向队尾第一个可以插入元素的空位，因为是循环数组，所以head 不一定从是从0开始，tail 也不一定总是比head大。</li>
</ul>
</li>
<li><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>由双向链表实现。LinkedList一般应该归在List下，只不过也实现了Deque接口，可以作为队列来使用。等于说，LinkedList 同时实现了Stack、Queue、PriorityQueue的所有功能</li>
<li>在使用LinkedList作为队列时，可以使用offer()方法将元素添加到队列的末尾，使用poll()方法从队列的头部删除元素。另外，由于 LinkedList 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。</li>
</ul>
</li>
<li><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul>
<li>一种优先级队列，它的出队顺序与元素的优先级有关，执行remove或者poll方法，返回的总是优先级最高的元素。优先级要求元素实现Comparable接口或者Comparator接口</li>
</ul>
</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map保存的是键值对，键要求保持唯一性，值可以重复</p>
<ul>
<li><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>无序。HashMap实现了Map接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问</li>
<li>HashMap中的键和值都可以为null。如果键为null，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者forEach方法遍历HashMap中的键值对。</li>
<li>HashMap有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是16，负载因子是0.75。</li>
</ul>
</li>
<li><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>有序。LinkedHashMap是HashMap的子类，它使用链表来记录插入&#x2F;访问元素的顺序。LinkedHashMap 可以看作是HashMap+LinkedList的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序</li>
</ul>
</li>
<li><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul>
<li>实现了SortedMap接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。</li>
<li>内部使用红黑树来实现键的排序和查找</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-ArrayList详解-x3D-x3D"><a href="#x3D-x3D-ArrayList详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ArrayList详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList详解&#x3D;&#x3D;</h4><p><a target="_blank" rel="noopener" href="https://javabetter.cn/collection/arraylist.html#_10%E3%80%81%E6%80%BB%E7%BB%93">京东实习一面：聊聊Java ArrayList，扩容机制了解吗？ | 二哥的Java进阶之路 (javabetter.cn)</a></p>
<p><code>add()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">/**
 * 将指定元素添加到 ArrayList 的末尾
 * @param e 要添加的元素
 * @return 添加成功返回 true
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 确保 ArrayList 能够容纳新的元素</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 在 ArrayList 的末尾添加指定元素</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 确保 ArrayList 能够容纳指定容量的元素
 * @param minCapacity 指定容量的最小值
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果elementData是默认空数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        <span class="token comment">// 使用 DEFAULT_CAPACITY 和指定容量的最小值中的较大值</span>
        minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保容量能够容纳指定容量的元素</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 检查并确保集合容量足够，如果需要则增加集合容量。
 * @param minCapacity 所需最小容量
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 检查是否超出了数组范围，确保不会溢出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果需要增加容量，则调用 grow 方法</span>
        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素
 * @param minCapacity 指定容量的最小值
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 检查是否会导致溢出，oldCapacity 为当前数组长度</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩容至原来的1.5倍</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果还是小于指定容量的最小值</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span> <span class="token comment">// 直接扩容至指定容量的最小值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果超出了数组的最大长度</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩容至数组的最大长度</span>
    <span class="token comment">// 将当前数组复制到一个新数组中，长度为 newCapacity</span>
    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>add(int index, E element)</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 在指定位置插入一个元素。
 *
 * @param index   要插入元素的位置
 * @param element 要插入的元素
 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查索引是否越界</span>

    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 确保容量足够，如果需要扩容就扩容</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
            size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 index 及其后面的元素向后移动一位</span>
    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span> <span class="token comment">// 将元素插入到指定位置</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 元素个数加一</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>set()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 用指定元素替换指定位置的元素。
 * @param index   要替换的元素的索引
 * @param element 要存储在指定位置的元素
 * @return 先前在指定位置的元素
 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查索引是否越界</span>

    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取原来在指定位置上的元素</span>
    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span> <span class="token comment">// 将新元素替换到指定位置上</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token comment">// 返回原来在指定位置上的元素</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>remove()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 删除指定位置的元素。
 * @param index 要删除的元素的索引
 * @return 先前在指定位置的元素
 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查索引是否越界</span>

    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取要删除的元素</span>

    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 计算需要移动的元素个数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果需要移动元素，就用 System.arraycopy 方法实现</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span>

    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token comment">// 返回被删除的元素</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 删除列表中第一次出现的指定元素（如果存在）。
 * @param o 要删除的元素
 * @return 如果列表包含指定元素，则返回 true；否则返回 false
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要删除的元素是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果找到了 null 元素</span>
                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 fastRemove 方法快速删除元素</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 返回 true，表示成功删除元素</span>
            <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要删除的元素不是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果找到了要删除的元素</span>
                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 fastRemove 方法快速删除元素</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 返回 true，表示成功删除元素</span>
            <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 如果找不到要删除的元素，则返回 false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>indexOf()和lastIndexOf()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 返回指定元素在列表中第一次出现的位置。
 * 如果列表不包含该元素，则返回 -1。
 * @param o 要查找的元素
 * @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了 null 元素</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回元素的索引</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素不是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了要查找的元素</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回元素的索引</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果找不到要查找的元素，则返回 -1</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 返回指定元素在列表中最后一次出现的位置。
 * 如果列表不包含该元素，则返回 -1。
 * @param o 要查找的元素
 * @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 从后往前遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了 null 元素</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回元素的索引</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素不是 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 从后往前遍历列表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了要查找的元素</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回元素的索引</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果找不到要查找的元素，则返回 -1</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>contains()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-LinkedList详解-x3D-x3D"><a href="#x3D-x3D-LinkedList详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;LinkedList详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;LinkedList详解&#x3D;&#x3D;</h4><p><a target="_blank" rel="noopener" href="https://javabetter.cn/collection/linkedlist.html#_01%E3%80%81linkedlist%E7%9A%84%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95">LinkedList控诉：我爹都嫌弃我！ | 二哥的Java进阶之路 (javabetter.cn)</a></p>
<p>双向链表，无大小限制</p>
<p><code>add()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 将指定的元素添加到列表的尾部。
 * @param e 要添加到列表的元素
 * @return 始终为 true（根据 Java 集合框架规范）
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在列表的尾部添加元素</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 添加元素成功，返回 true</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 在列表的尾部添加指定的元素。
 *
 * @param e 要添加到列表的元素
 */</span>
<span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span> <span class="token comment">// 获取链表的最后一个节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的节点设置为链表最后一个节点</span>
    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">// 将新的节点设置为链表的最后一个节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果链表为空，则将新节点设置为头节点</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">// 否则将新节点链接到链表的尾部</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 增加链表的元素个数</span>
<span class="token punctuation">&#125;</span>

<span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 头插法     </span>
<span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>   <span class="token comment">// 尾插法    - linkLast()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>remove()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 remove()：删除第一个节点            - removeFirst()
 remove(int)：删除指定位置的节点      - unlink
 remove(Object)：删除指定元素的节点
 removeFirst()：删除第一个节点
 removeLast()：删除最后一个节点
*/</span>

<span class="token comment">/**
 * 删除指定位置上的元素。
 * @param index 要删除的元素的索引
 * @return 从列表中删除的元素
 * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查索引是否越界</span>
    <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除指定位置的节点，并返回节点的元素</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 从链表中删除指定节点。
 *
 * @param x 要删除的节点
 * @return 从链表中删除的节点的元素
 */</span>
<span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span> <span class="token comment">// 获取要删除节点的元素</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 获取要删除节点的下一个节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span> <span class="token comment">// 获取要删除节点的上一个节点</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要删除节点是第一个节点</span>
        first <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">// 将链表的头节点设置为要删除节点的下一个节点</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">// 将要删除节点的上一个节点指向要删除节点的下一个节点</span>
        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将要删除节点的上一个节点设置为空</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要删除节点是最后一个节点</span>
        last <span class="token operator">=</span> prev<span class="token punctuation">;</span> <span class="token comment">// 将链表的尾节点设置为要删除节点的上一个节点</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span> <span class="token comment">// 将要删除节点的下一个节点指向要删除节点的上一个节点</span>
        x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将要删除节点的下一个节点设置为空</span>
    <span class="token punctuation">&#125;</span>

    x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将要删除节点的元素设置为空</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 减少链表的元素个数</span>
    <span class="token keyword">return</span> element<span class="token punctuation">;</span> <span class="token comment">// 返回被删除节点的元素</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>set()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。
 * @param index 要替换元素的位置（从 0 开始）
 * @param element 要插入的元素
 * @return 替换前的元素
 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index >= size()）
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查索引是否超出范围</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取要替换的节点</span>
    <span class="token class-name">E</span> oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span> <span class="token comment">// 获取要替换节点的元素</span>
    x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span> <span class="token comment">// 将要替换的节点的元素设置为指定元素</span>
    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span> <span class="token comment">// 返回替换前的元素</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 获取链表中指定位置的节点。
 * @param index 节点的位置（从 0 开始）
 * @return 指定位置的节点
 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index >= size()）
 */</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果索引在链表的前半部分</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 从头节点开始向后遍历链表，直到找到指定位置的节点</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token comment">// 返回指定位置的节点</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果索引在链表的后半部分</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 从尾节点开始向前遍历链表，直到找到指定位置的节点</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token comment">// 返回指定位置的节点</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>indexOf(Object)和get(int)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 返回链表中首次出现指定元素的位置，如果不存在该元素则返回 -1。
 * @param o 要查找的元素
 * @return 首次出现指定元素的位置，如果不存在该元素则返回 -1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始化索引为 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素为 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从头节点开始向后遍历链表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了要查找的元素</span>
                <span class="token keyword">return</span> index<span class="token punctuation">;</span> <span class="token comment">// 返回该元素的索引</span>
            index<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 索引加 1</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要查找的元素不为 null</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从头节点开始向后遍历链表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果找到了要查找的元素</span>
                <span class="token keyword">return</span> index<span class="token punctuation">;</span> <span class="token comment">// 返回该元素的索引</span>
            index<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 索引加 1</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有找到要查找的元素，则返回 -1</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-Stack详解-x3D-x3D"><a href="#x3D-x3D-Stack详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Stack详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;Stack详解&#x3D;&#x3D;</h4><h5 id="自定义栈数组实现"><a href="#自定义栈数组实现" class="headerlink" title="自定义栈数组实现"></a>自定义栈数组实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">&#123;</span> 
     <span class="token keyword">private</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
     <span class="token keyword">private</span> <span class="token keyword">int</span> top<span class="token punctuation">;</span> 
     <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span> 
    
    <span class="token comment">// 初始化栈</span>
    <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    	arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> 
     	capacity <span class="token operator">=</span> size<span class="token punctuation">;</span> 
     	top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 压栈</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
         	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"溢出\n程序终止\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         	<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     	<span class="token punctuation">&#125;</span> 
  
     	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"压入 "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     	arr<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 出栈</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
         	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈是空的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         	<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     	<span class="token punctuation">&#125;</span> 
     	<span class="token keyword">return</span> arr<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 返回栈大小</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     	<span class="token keyword">return</span> top <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
    <span class="token comment">// 判空</span>
    <span class="token keyword">public</span> <span class="token class-name">Boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     	<span class="token keyword">return</span> top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
    <span class="token comment">// 判满</span>
    <span class="token keyword">public</span> <span class="token class-name">Boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     	<span class="token keyword">return</span> top <span class="token operator">==</span> capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> 
 	<span class="token punctuation">&#125;</span>
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Stack类-（java-util-Stack）继承自Vector，是线程安全"><a href="#Stack类-（java-util-Stack）继承自Vector，是线程安全" class="headerlink" title="Stack类 （java.util.Stack）继承自Vector，是线程安全"></a>Stack类 （java.util.Stack）继承自<code>Vector</code>，是线程安全</h5><p>在Java中，推荐使用ArrayDeque来代替Stack，因为ArrayDeque是非线程安全的，性能更好</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> 
  <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">protected</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> elementCount<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>push()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     <span class="token function">addElement</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token keyword">return</span> item<span class="token punctuation">;</span> 
 <span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addElement</span><span class="token punctuation">(</span><span class="token class-name">E</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     modCount<span class="token operator">++</span><span class="token punctuation">;</span> 
     <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> 
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>pop()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
     <span class="token class-name">E</span> obj<span class="token punctuation">;</span> 
     <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     obj <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token function">removeElementAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token keyword">return</span> obj<span class="token punctuation">;</span> 
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-HashMap详解-x3D-x3D"><a href="#x3D-x3D-HashMap详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;HashMap详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap详解&#x3D;&#x3D;</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/449337470">hashmap头插法和尾插法区别_一个跟面试官扯皮半个小时的HashMap（看这一篇就足够了） - 知乎</a></p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值，算法时间复杂度可以达到 O(1)。在实际应用中，HashMap可以用于缓存、索引等场景。</p>
<p>HashMap的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。    当通过键查找值时，HashMap会根据键的哈希值计算出数组下标，并查找对应的值</p>
<h5 id="hash方法的原理"><a href="#hash方法的原理" class="headerlink" title="hash方法的原理"></a>hash方法的原理</h5><p><strong>hash方法是用来做哈希值优化</strong></p>
<p><strong>hash方法增加了随机性（低位随机性加大，掺杂部分高位特征，高位信息也得到保留），让元素分布更加均衡，减少碰撞</strong></p>
<p>hash 方法的原理是，先获取key对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。</p>
<p>为什么要进行异或操作呢？因为对于hashCode的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。</p>
<p>然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是HashMap中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// hash方法源码 将key的hashCode值进行处理，得到最终的哈希值</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果键值为 null，则哈希码为0（即如果键为null，则存放在第一个位置）；</span>
    <span class="token comment">// 否则，通过调用hashCode()方法获取键的哈希码，并将其与右移16位的哈希码进行异或运算</span>
    <span class="token comment">// 将哈希码向右移动16位，相当于将原来的哈希码分成了两个 16 位的部分</span>
    <span class="token comment">// 理论上，哈希值（哈希码）是一个int类型，范围从-2147483648 到 2147483648</span>
    <span class="token comment">// 哈希值是不能直接拿来用的。</span>
    <span class="token comment">// 先和数组长度做与运算（(n - 1) &amp; hash）取模预算/取余运算，用得到的值来访问数组下标才行</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h5><p>HashMap扩容是通过resize方法实现。JDK 8中融入了红黑树（链表长度超过8的时候，会将链表转化为红黑树提高查询效率）</p>
<p>当我们往HashMap中不断添加元素时，HashMap会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。在进行扩容操作时，HashMap会先将数组的长度扩大一倍，然后将原来的元素重新散列到新的数组中。由于元素的位置是通过key的hash和数组长度进行与运算得到的，因此在数组长度扩大后，元素的位置也会发生一些改变。一部分索引不变，另一部分索引为“原索引+旧容量</p>
<p><code>JDK 7源码</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// newCapacity为新容量</span>
<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 小数组，临时过度下</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token comment">// 扩容前旧容量</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// MAXIMUM_CAPACITY 为最大容量，2的30次方 = 1&lt;&lt;30</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2的31次方-1</span>
        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 初始化一个新的数组（大容量）</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 把小数组的元素转移到大数组中</span>
    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 引用新的大数组</span>
    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>
    <span class="token comment">// 重新计算阈值</span>
    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。
首先，方法获取当前HashMap的旧数组 oldTable 和旧容量oldCapacity。如果旧容量已经达到HashMap支持的最大容量MAXIMUM_CAPACITY（2^30），就将新的阈值threshold 调整为Integer.MAX_VALUE（2^31-1），这是因为HashMap的容量不能超过MAXIMUM_CAPACITY。

因为2^31-1（Integer.MAX_VALUE）-2^30（MAXIMUM_CAPACITY）= 2^30-1，刚好相差一倍
（HashMap 每次扩容都是之前的一倍）

接着，方法创建一个新的数组newTable，将旧数组oldTable中的元素转移到新数组newTable中。转移过程是通过调用transfer方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。

转移完成后，方法将HashMap内部的数组引用table指向新数组newTable，并重新计算阈值 threshold。新的阈值是新容量newCapacity乘以负载因子loadFactor的结果，但如果计算结果超过了HashMap支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为MAXIMUM_CAPACITY + 1，这是因为HashMap的元素数量不能超过 MAXIMUM_CAPACITY。
*/</span>

<span class="token comment">// 新容量newCapacity的计算，可以避免新容量太小或太大导致哈希冲突过多或者浪费空间</span>
	<span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> newCapacity <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	newCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	newCapacity <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

<span class="token comment">// transfer 方法用来转移，将旧的小数组元素拷贝到新的大数组中</span>
<span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 新的容量</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 遍历小数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 拉链法，相同 key 上的不同值</span>
            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment">// 是否需要重新计算 hash</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 同一位置上的新元素被放在链表的头部</span>
            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token comment">// 放在新的数组上</span>
            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>

            <span class="token comment">// 链表上的下一个元素</span>
            e <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。
在方法中，首先获取新哈希表（数组）的长度newCapacity，然后遍历旧哈希表中的每个Entry。对于每个Entry，使用拉链法将相同key值的不同value值存储在同一个链表中。如果rehash为true，则需要重新计算键的哈希值，并将新的哈希值存储在Entry的hash属性中。
接着，根据新哈希表的长度和键的哈希值，计算Entry在新数组中的位置i，然后将该Entry添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。
最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>拉链法使用了单链表的头插入方式,会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上</strong></p>
<p><code>JDK 8源码</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token comment">// 获取原来的数组 table</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 获取数组长度 oldCap</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span> <span class="token comment">// 获取阈值 oldThr</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果原来的数组 table 不为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> 
                  oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// zero initial threshold signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 计算新的 resize 上限</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span> <span class="token comment">// 将新阈值赋值给成员变量 threshold</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 创建新数组 newTab</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span> <span class="token comment">// 将新数组newTab赋值给成员变量 table</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果旧数组oldTab不为空</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历旧数组的每个元素</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果该元素不为空</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将旧数组中该位置的元素置为null，以便垃圾回收</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果该元素没有冲突</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 直接将该元素放入新数组</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment">// 如果该元素是树节点</span>
                    <span class="token comment">// 将该树节点分裂成两个链表</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果该元素是链表</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 低位链表的头结点和尾结点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 高位链表的头结点和尾结点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历该链表</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果该元素在低位链表中</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>       <span class="token comment">// 低位链表没有结点</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>           <span class="token comment">// 将该元素作为低位链表的头结点</span>
                            <span class="token keyword">else</span>                     <span class="token comment">// 低位链表已有结点</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>     <span class="token comment">// 将该元素加入低位链尾部</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新低位链表的尾结点</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果该元素在高位链表中</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token comment">// 如果高位链表还没有结点</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>          <span class="token comment">// 将该元素作为高位链表头结点</span>
                            <span class="token keyword">else</span>				     <span class="token comment">// 如果高位链表已经有结点</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>     <span class="token comment">// 将该元素加入高位链表的尾部</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新高位链表的尾结点</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果低位链表不为空</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将低位链表的尾结点指向 null，以便垃圾回收</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment">// 将低位链表作为新数组对应位置的元素</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果高位链表不为空</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 将高位链表的尾结点指向 null，以便垃圾回收</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span> <span class="token comment">// 将高位链表作为新数组对应位置的元素</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span> <span class="token comment">// 返回新数组</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
1、获取原来的数组table、数组长度 oldCap 和阈值 oldThr。
2、如果原来的数组table 不为空，则根据扩容规则计算新数组长度newCap和新阈值newThr，然后将原数组中的元素复制到新数组中。
3、如果原来的数组table为空但阈值oldThr不为零，则说明是通过带参数构造方法创建的HashMap，此时将阈值作为新数组长度newCap。
4、如果原来的数组table和阈值oldThr都为零，则说明是通过无参数构造方法创建的HashMap，此时将默认初始容量DEFAULT_INITIAL_CAPACITY（16）和默认负载因子DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度newCap和新阈值newThr。
5、计算新阈值threshold，并将其赋值给成员变量threshold。
6、创建新数组newTab，并将其赋值给成员变量table。
7、如果旧数组oldTab不为空，则遍历旧数组的每个元素，将其复制到新数组中。
8、返回新数组newTab
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>JDK7 索引的计算方式<code>hashCode % table.length</code></p>
<p>JDK8 索引的计算方式<code>hash &amp; (newCapacity - 1)</code></p>
<p>在JDK 8的新hash算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定规律</p>
<h5 id="加载因子为什么是0-75"><a href="#加载因子为什么是0-75" class="headerlink" title="加载因子为什么是0.75"></a>加载因子为什么是0.75</h5><p>加载因子是用来表示HashMap中数据的填满程度.加载因子&#x3D;填入哈希表中的数据个数&#x2F;哈希表的长度</p>
<p>HashMap 是通过拉链法来解决哈希冲突的。为了减少哈希冲突发生概率，当HashMap的数组长度达到一个<strong>临界值</strong>的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。临界值&#x3D;初始容量*加载因子</p>
<p>Java 8之前，HashMap使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（LinkedList的查找效率为 O（n））就会受到影响。</p>
<p>Java 8中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为TreeNode），红黑树（TreeMap）是一种高效的平衡树结构，能够在 O(log n)的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高HashMap的性能和可伸缩性</p>
<p>理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布，平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）&#x2F; factorial（k））</p>
<p>一般选择0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。</p>
<p>如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。</p>
<p>如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择0.75是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点</p>
<h5 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h5><p>三方面原因</p>
<ul>
<li>多线程下扩容会死循环<ul>
<li>JDK 7时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面。扩容的时候就有可能导致出现环形链表，造成死循环</li>
<li>JDK 8时已经修复了这个问题，扩容时会保持链表原来的顺序</li>
</ul>
</li>
<li>多线程下put会导致元素丢失<ul>
<li>计算index，并对null做处理。多个线程同时插入空桶，导致后者覆盖前者，先插入元素丢失</li>
</ul>
</li>
<li>put和get并发时会导致get到null<ul>
<li>线程1执行put时，因为元素个数超出阈值而导致出现扩容，线程2此时执行get，就有可能出现这个问题</li>
</ul>
</li>
</ul>
<p>HashMap是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap的不变性。具体来说，如果在一个线程正在遍历HashMap的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。</p>
<p>为了解决这个问题，Java提供线程安全的HashMap实现类<a target="_blank" rel="noopener" href="https://javabebetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>。ConcurrentHashMap内部采用分段锁（Segment），将整个Map拆分为多个小的HashMap，每个小HashMap都有自己的锁，不同线程可以同时访问不同小 Map，从而实现线程安全。在进行插入、删除和扩容等操作时，只需锁住当前小Map，不会对整个Map 进行锁定，提高了并发访问效率。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>HashMap采用数组+链表&#x2F;红黑树的存储结构，能够在O(1)的时间复杂度内实现元素的添加、删除、查找等操作。</li>
<li>HashMap是线程不安全的，因此在多线程环境下需要使用<a target="_blank" rel="noopener" href="https://javabebetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>来保证线程安全。</li>
<li>HashMap的扩容机制是通过扩大数组容量和重新计算hash值来实现的，扩容时需要重新计算所有元素的hash值，因此在元素较多时扩容会影响性能。</li>
<li>在Java 8中，HashMap的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。</li>
<li>HashMap中key是唯一的，如果要存储重复的 key，则后面的值会覆盖前面的值。</li>
<li>HashMap 的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为16，加载因子为0.75。</li>
<li>HashMap在遍历时是无序的，因此如果需要有序遍历，可以使用<a target="_blank" rel="noopener" href="https://javabebetter.cn/collection/treemap.html">TreeMap</a>。</li>
</ul>
<h4 id="x3D-x3D-LinkedHashMap详解-x3D-x3D"><a href="#x3D-x3D-LinkedHashMap详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;LinkedHashMap详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;LinkedHashMap详解&#x3D;&#x3D;</h4><p><strong>LinkedHashMap可以维持插入顺序</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    	<span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
    	<span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token comment">// put调用的内部方法newNode()</span>
    <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    
    <span class="token comment">/**
 	* 将指定节点插入到链表的尾部
 	* @param p 要插入的节点
 	*/</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// 获取链表的尾节点</span>
    	tail <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 将p设为尾节点</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        	head <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果链表为空，则将p设为头节点</span>
    	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        	p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span> <span class="token comment">// 将p的前驱节点设为链表的尾节点</span>
        	last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 将链表的尾节点的后继节点设为p</span>
    	<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// LinkedHashMap&lt;String, String> map = new LinkedHashMap&lt;>(16, .75f, true);</span>
<span class="token comment">// 第三个参数为true表示LinkedHashMap要维护访问顺序；否则不维护插入顺序。默认是false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最不经常访问的放在头部。可以使用LinkedHashMap来实现LRU缓存</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>			<span class="token comment">// 在调用 get() 方法的时候被调用</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>		<span class="token comment">// 在调用 put() 方法的时候被调用</span>
<span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>			<span class="token comment">// 在调用 remove() 方法的时候被调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。</p>
<p>LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。</p>
<h4 id="x3D-x3D-TreeMap详解-x3D-x3D"><a href="#x3D-x3D-TreeMap详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;TreeMap详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;TreeMap详解&#x3D;&#x3D;</h4><p>TreeMap由红黑树实现，可以保持元素的自然顺序，或者实现了Comparator接口的自定义顺序</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡。</p>
<ul>
<li>1）每个节点都只能是红色或者黑色</li>
<li>2）根节点是黑色</li>
<li>3）每个叶节点（NIL 节点，空节点）是黑色的。</li>
<li>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。</li>
<li>5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是查找效率仍然较高。红黑树适用于读写操作比较均衡的场景。</p>
<h5 id="自然顺序"><a href="#自然顺序" class="headerlink" title="自然顺序"></a>自然顺序</h5><p>默认情况下TreeMap根据key的自然顺序排列</p>
<h5 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h5><p>可以在声明TreeMap对象的时候指定排序规则</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">></span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        <span class="token comment">// 获取最后一个key </span>
<span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；		  <span class="token comment">// 获取第一个key </span>
<span class="token function">headMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        <span class="token comment">// 获取到指定key之前的 key </span>
<span class="token function">tailMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        <span class="token comment">// 获取指定key之后的key（包括指定key）</span>
<span class="token function">subMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// [a,b）区间的key</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h5><table>
<thead>
<tr>
<th>特性</th>
<th>TreeMap</th>
<th>HashMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>
<tbody><tr>
<td>排序</td>
<td>支持</td>
<td>不</td>
<td>不</td>
</tr>
<tr>
<td>插入顺序</td>
<td>不</td>
<td>不</td>
<td>保证</td>
</tr>
<tr>
<td>查找效率</td>
<td>O(log n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间占用</td>
<td>通常较大</td>
<td>通常较小</td>
<td>通常较大</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要排序的场景</td>
<td>无需排序的场景</td>
<td>需要保持插入顺序</td>
</tr>
</tbody></table>
<h4 id="x3D-x3D-ArrayDeque详解-x3D-x3D"><a href="#x3D-x3D-ArrayDeque详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ArrayDeque详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayDeque详解&#x3D;&#x3D;</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>
                           <span class="token keyword">implements</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span>
<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>（双端队列）</p>
<p>需要使用队列的时候，也可以选择ArrayDeque</p>
<h5 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h5><p><em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。</p>
<ul>
<li><p><em>Deque</em>与<em>Queue</em>对应接口</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody></table>
</li>
<li><p><em>Deque</em>与<em>Stack</em>对应接口</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)</td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>offerFirst(e)</td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>pollFirst()</td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td>peek()</td>
<td>getFirst()</td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="ArrayDeque-1"><a href="#ArrayDeque-1" class="headerlink" title="ArrayDeque"></a><em>ArrayDeque</em></h5><p><em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点</p>
<p><em>ArrayDeque</em>非线程安全（not thread-safe），当多个线程同时使用时需要手动同步；另外，该容器不允许放入<code>null</code>元素</p>
<p><strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong></p>
<p><code>插入</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//不允许放入null</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//2.下标是否越界</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span><span class="token comment">//1.空间是否够用</span>
        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扩容</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，</span>
<span class="token comment">// 意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题</span>
<span class="token comment">// 下标越界处理 head = (head - 1) &amp; (elements.length - 1)，相当于取余，同时解决head为负值情况</span>
<span class="token comment">// doubleCapacity() 申请一个更大的数组（原数组的两倍）复制数组（head右侧 + head左侧）</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//不允许放入null</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//赋值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> head<span class="token punctuation">)</span><span class="token comment">//下标越界处理</span>
        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扩容</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>删除并返回</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">E</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//null值意味着deque为空</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//let GC work</span>
    head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下标越界处理</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//tail的上一个位置是最后一个元素</span>
    <span class="token class-name">E</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//null值意味着deque为空</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    elements<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//let GC work</span>
    tail <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>返回</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> elements<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// elements[head] is null if deque empty</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> elements<span class="token punctuation">[</span><span class="token punctuation">(</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>ArrayDeque是Java标准库中的一种双端队列实现，底层基于数组实现。与LinkedList相比，ArrayDeque性能更优，因为它使用连续的内存空间存储元素，可以更好地利用CPU缓存，在大多数情况下也更快。</p>
<p>使用LinkedList时，需要频繁进行内存分配和释放，而ArrayDeque在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用CPU缓存，提高访问效率。</p>
<p>rrayDeque的扩容策略（当ArrayDeque中的元素数量达到数组容量时，就需要进行扩容操作，扩容时会将数组容量扩大为原来的两倍）可以在一定程度上减少数组复制的次数和时间消耗，同时保证ArrayDeque的性能和空间利用率。</p>
<h4 id="x3D-x3D-PriorityQueue详解-x3D-x3D"><a href="#x3D-x3D-PriorityQueue详解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;PriorityQueue详解&#x3D;&#x3D;"></a>&#x3D;&#x3D;PriorityQueue详解&#x3D;&#x3D;</h4><p>PriorityQueue是Java中的一个基于优先级堆的优先队列实现，它能够在O(log n)时间复杂度内实现元素的插入和删除操作，并且能够自动维护队列中元素的优先级顺序</p>
<p>堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。因为完全二叉树的结构比较规则，所以可以使用数组来存储堆的元素，而不需要使用指针等额外的空间。在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为i，则其父节点下标为i&#x2F;2，其左子节点下标为2i，其右子节点下标为2i+1</p>
<p><code>siftUp()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 用于插入元素x并维持堆的特性</span>
<span class="token comment">// 调整的过程为：</span>
<span class="token comment">// 从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x >= queue[parent]为止</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//parentNo = (nodeNo-1)/2</span>
        <span class="token class-name">Object</span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//调用比较器的比较方法</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>siftDown()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 对堆进行调整</span>
<span class="token comment">// 从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x&lt;=左右孩子中的任何一个为止</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>
        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//leftNo = parentNo*2+1</span>
        <span class="token class-name">Object</span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>
            comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment">//然后用c取代原来的值</span>
        k <span class="token operator">=</span> child<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p>PriorityQueue 是一个非常常用的数据结构，它是一种特殊的堆（Heap）实现，可以用来高效地维护一个有序的集合。</p>
<ul>
<li>它的底层实现是一个数组，通过堆的性质来维护元素的顺序。</li>
<li>取出元素时按照优先级顺序（从小到大或者从大到小）进行取出。</li>
<li>如果需要指定排序，元素必须实现 Comparable 接口或者传入一个 Comparator 来进行比较</li>
</ul>
<h4 id="x3D-x3D-ArrayList和LinkedList的区别-x3D-x3D"><a href="#x3D-x3D-ArrayList和LinkedList的区别-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ArrayList和LinkedList的区别&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList和LinkedList的区别&#x3D;&#x3D;</h4><img src="C:\Users\cxl\AppData\Roaming\Typora\typora-user-images\image-20241011153319958.png" alt="image-20241011153319958" style="zoom:33%;" />

<h4 id="x3D-x3D-深入理解Java泛型-x3D-x3D"><a href="#x3D-x3D-深入理解Java泛型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;深入理解Java泛型&#x3D;&#x3D;"></a>&#x3D;&#x3D;深入理解Java泛型&#x3D;&#x3D;</h4><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040327946">Java基础（ 泛型之 和 上下界限） - 个人文章 - SegmentFault 思否</a></p>
<p>使用<strong>类型参数</strong>解决了元素的不确定性</p>
<p>一个泛型类就是具有一个或多个类型变量的类。可以在一个非泛型的类（或者泛型类）中定义泛型方法</p>
<p>限定符 <code>extends</code> 可以缩小泛型的类型范围</p>
<p>Java虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用<code>Object</code>）</p>
<p>通配符使用英文的问号<code>（?）</code>来表示。在我们创建一个泛型对象时，可以使用关键字 <code>extends</code> 限定子类，也可以使用关键字 <code>super</code>限定父类</p>
<h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>在Java中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性</p>
<ul>
<li>类型参数化<ul>
<li>泛型的本质是参数化类型，也就是说，在定义类、接口或方法时，可以使用一个或多个类型参数来表示参数化类型</li>
</ul>
</li>
<li>类型擦除<ul>
<li>泛型在编译时会将泛型类型擦除，将泛型类型替换成Object类型。这是为了向后兼容，避免对原有Java代码造成影响</li>
<li>Java泛型只在编译时起作用，运行时并不会保留泛型类型信息</li>
</ul>
</li>
<li>通配符<ul>
<li>通配符用于表示某种未知的类型。使用通配符可以使方法更加通用，同时保证类型安全。</li>
<li>上限通配符 <code>&lt;? extends T&gt;</code>，表示通配符只能接受T或T的子类</li>
<li>下限通配符（Lower Bounded Wildcards）用super关键字来声明，其语法形式为<code>&lt;? super T&gt;</code>，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-Iterator和Iterable区别-x3D-x3D"><a href="#x3D-x3D-Iterator和Iterable区别-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Iterator和Iterable区别&#x3D;&#x3D;"></a>&#x3D;&#x3D;Iterator和Iterable区别&#x3D;&#x3D;</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在Java中，我们对List进行遍历的时候，主要有这么三种方式</span>

<span class="token comment">// 1. for循环</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 2. 迭代器</span>
<span class="token class-name">Iterator</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 3. for-each 本质是Iterator</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> ob <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ob<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Iterator是个接口，JDK1.2的时候就有了，用来改进Enumeration接口：</p>
<ul>
<li>允许删除元素（增加了remove方法）</li>
<li>优化了方法名（Enumeration中是hasMoreElements和nextElement，不简洁）</li>
</ul>
<h5 id="Iterator源码"><a href="#Iterator源码" class="headerlink" title="Iterator源码"></a>Iterator源码</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">// 判断集合中是否存在下一个对象</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 返回集合中的下一个对象，并将访问指针移动一位</span>
    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 删除集合中调用next()方法返回的对象</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">// JDK1.8时，Iterable接口中新增forEach方法</span>
    <span class="token comment">/*
    该方法实现时首先会对 action 参数进行非空检查，为null抛出NullPointerException异常。
    然后使用for-each循环遍历集合中的元素，并对每个元素调用action.accept(t)方法执行指定的操作。
    由于Iterable是Java集合框架中所有集合类型的基本接口，该方法可被所有实现Iterable接口集合类型使用
    */</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> action<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="x3D-x3D-Java-foreach循环陷阱-x3D-x3D"><a href="#x3D-x3D-Java-foreach循环陷阱-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java foreach循环陷阱&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java foreach循环陷阱&#x3D;&#x3D;</h4><h5 id="为什么阿里的Java开发手册里会强制不要在foreach里进行元素的删除操作"><a href="#为什么阿里的Java开发手册里会强制不要在foreach里进行元素的删除操作" class="headerlink" title="为什么阿里的Java开发手册里会强制不要在foreach里进行元素的删除操作?"></a>为什么阿里的Java开发手册里会强制不要在foreach里进行元素的删除操作?</h5><h5 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a><code>fail-fast</code></h5><ul>
<li>一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>foreach循环反编译后，生成迭代器遍历但调用的是集合自身的remove(E)方法。</p>
<ul>
<li>remove方法调用fastRemove方法</li>
<li>fastRemove方法中会执行<code>modCount++</code></li>
</ul>
<p>下次遍历后，执行迭代器的next方法。next方法调用<code>checkForComodification</code>方法。检查修改次数是否一致</p>
<p>在迭代ArrayList时，如果迭代过程中发现modCount的值与迭代器的expectedModCount不一致，则说明ArrayList已被修改过，此时会抛出ConcurrentModificationException异常。这种机制可以保证迭代器在遍历ArrayList时，不会遗漏或重复元素，同时也可以在多线程环境下检测到并发修改问题。</p>
<h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>因为foreach循环是基于迭代器实现的，而迭代器在遍历集合时会维护一个expectedModCount属性来记录集合被修改的次数。如果在foreach循环中执行删除操作会导致expectedModCoun 属性值与实际的modCount属性值不一致，从而导致迭代器的hasNext()和next()方法抛出ConcurrentModificationException异常。</p>
<p>为了避免这种情况，应该使用迭代器的remove()方法来删除元素，该方法会在删除元素后更新迭代器状态，确保循环的正确性。如果需要在循环中删除元素，应该使用迭代器的remove()方法，而不是集合自身的remove()方法。</p>
<h5 id="正确删除元素"><a href="#正确删除元素" class="headerlink" title="正确删除元素"></a>正确删除元素</h5><ul>
<li>remove后break<ul>
<li>break后循环就不再遍历了，意味着Iterator的next方法不再执行了，也就意味着 <code>checkForComodification</code> 方法不再执行了，所以异常也就不会抛出</li>
<li>当 List 中有重复元素要删除的时候，break不合适</li>
</ul>
</li>
<li>for循环<ul>
<li>可以避开fail-fast保护机制，也就说remove元素后不再抛出异常</li>
<li>程序在原则上是有问题的。list的大小在remove 后发生了变化，有元素被跳过</li>
</ul>
</li>
<li>使用Iterator<ul>
<li>Iterator的remove方法就可以避开fail-fast保护机制</li>
<li>删除完会执行<code>expectedModCount = modCount</code>，保证了expectedModCount与modCount的同步</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-Comparable和Comparator区别-x3D-x3D"><a href="#x3D-x3D-Comparable和Comparator区别-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Comparable和Comparator区别&#x3D;&#x3D;"></a>&#x3D;&#x3D;Comparable和Comparator区别&#x3D;&#x3D;</h4><h5 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// compareTo() 方法</span>
<span class="token comment">// 该方法的返回值可能为负数，零或者正数，</span>
<span class="token comment">// 代表该对象按排序规则小于、等于或者大于要比较的对象。</span>
<span class="token comment">// 如果指定对象的类型与此对象不能进行比较，则引发ClassCastException异常。指定泛型可以有效避免</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果一个类实现了Comparable接口（只需要重写compareTo()&#96;方法），就可以按照自制定规则将由它创建的对象进行比较</p>
<h5 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h5><p>Comparator接口的定义更复杂，核心方法有两个<code>compare()</code>和<code>equals()</code></p>
<p>可以让类E保持原貌，不主动实现Comparable接口。而是新建类实现Comparator&lt;E&gt;接口,可以实现多个比较器类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// compare(T o1, T o2) 返回值可能为负数，零或者正数，代表第一个对象小于、等于或者大于第二个对象。</span>
<span class="token comment">// equals(Object obj) 需要传入一个Object作为参数，并判断该 Object是否和Comparator保持一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Comparable和Comparator的区别"><a href="#Comparable和Comparator的区别" class="headerlink" title="Comparable和Comparator的区别"></a>Comparable和Comparator的区别</h5><ul>
<li>一个类实现Comparable接口，意味着该类对象可以直接进行比较（排序），但比较（排序）方式只有一种，单一。</li>
<li>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现Comparator接口）。</li>
<li>Comparable接口在<code>java.lang</code>包下，而 <code>Comparator</code> 接口在<code>java.util</code>包下</li>
<li>对象排序需要基于自然顺序选择<code>Comparable</code>，需要按照对象不同属性进行排序选择 <code>Comparator</code></li>
</ul>
<h4 id="x3D-x3D-详解WeakHashMap-x3D-x3D"><a href="#x3D-x3D-详解WeakHashMap-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;详解WeakHashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;详解WeakHashMap&#x3D;&#x3D;</h4><p>WeakHashMap其实和HashMap大多数行为是一样的，只是WeakHashMap不会阻止GC回收key对象（不是value）</p>
<h5 id="WeakHashMap如何不阻止对象回收"><a href="#WeakHashMap如何不阻止对象回收" class="headerlink" title="WeakHashMap如何不阻止对象回收"></a>WeakHashMap如何不阻止对象回收</h5><ul>
<li>WeakHashMap的Entry继承了WeakReference。</li>
<li>其中Key作为了WeakReference指向的对象</li>
<li>因此WeakHashMap利用了WeakReference的机制来实现不阻止GC回收Key</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> 
  <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    
  	<span class="token keyword">int</span> hash<span class="token punctuation">;</span>
  	<span class="token keyword">boolean</span> isNull<span class="token punctuation">;</span>
  	<span class="token class-name">V</span> value<span class="token punctuation">;</span>
  	<span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>
    
  	<span class="token keyword">interface</span> <span class="token class-name">Type</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
  		<span class="token class-name">R</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">&#125;</span>
    
  	<span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> object<span class="token punctuation">,</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  		<span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  		isNull <span class="token operator">=</span> key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  		hash <span class="token operator">=</span> isNull <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  		value <span class="token operator">=</span> object<span class="token punctuation">;</span>
  	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="如何删除被回收的key数据"><a href="#如何删除被回收的key数据" class="headerlink" title="如何删除被回收的key数据"></a>如何删除被回收的key数据</h5><p>在Javadoc中关于WeakHashMap有这样的描述，当key不再引用时，其对应的key&#x2F;value也会被移除。</p>
<p>那么是如何移除的呢，这里我们通常有两种假设策略</p>
<ul>
<li>当对象被回收的时候进行通知<ul>
<li>Java中没有一个可靠的通知回调，比如大家常说的finalize方法，其实也不是标准的，不同的JVM可以实现不同，甚至是不调用这个方法。故没有使用通知策略</li>
</ul>
</li>
<li>WeakHashMap轮询处理失效的Entry<ul>
<li>WeakHashMap采用轮询形式，在put&#x2F;get&#x2F;size等方法调用时都会先调用一个poll方法，检查并删除失效Entry</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><h4 id="x3D-x3D-IO知识体系-x3D-x3D"><a href="#x3D-x3D-IO知识体系-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;IO知识体系&#x3D;&#x3D;"></a>&#x3D;&#x3D;IO知识体系&#x3D;&#x3D;</h4><p><img src="C:\Users\cxl\AppData\Roaming\Typora\typora-user-images\image-20241011165601326.png" alt="image-20241011165601326"></p>
<p>IO，即in-out，输入-输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接</p>
<p>Java中是通过流处理IO</p>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道</p>
<ul>
<li>先进先出</li>
<li>顺序存储  （RandomAccessFile可随机访问）</li>
<li>只读或只写（每个流只能是输入流或输出流的一种，不能同时具备两个功能）</li>
</ul>
<h5 id="传输方式划分-4个抽象类"><a href="#传输方式划分-4个抽象类" class="headerlink" title="传输方式划分 - 4个抽象类"></a>传输方式划分 - 4个抽象类</h5><ul>
<li>字节（byte） 通常情况下，一个字节有 8 位（bit）。<ul>
<li><strong>InputStream类</strong><ul>
<li><code>int read()</code> 读取数据</li>
<li><code>int read(byte b[], int off, int len)</code>：从第off位置开始读，读取len长度的字节，放入数组b </li>
<li><code>long skip(long n)</code> 跳过指定个数的字节</li>
<li><code>int available()</code> 返回可读的字节数</li>
<li><code>void close()</code> 关闭流，释放资源</li>
</ul>
</li>
<li><strong>OutputStream类</strong><ul>
<li><code>void write(int b)</code> 写入一个字节，虽然参数是一个int类型，但只有低8位会写入，高24位舍弃</li>
<li><code>void write(byte b[], int off, int len)</code> 将数组b从off位置开始，长度为len的字节写入</li>
<li><code>void flush()</code> 强制刷新，将缓冲区的数据写入</li>
<li><code>void close()</code> 关闭流</li>
</ul>
</li>
</ul>
</li>
<li>字符（char） 可以是计算机中使用的字母数字符号。<ul>
<li><strong>Reader类</strong><ul>
<li><code>int read()</code> 读取单个字符</li>
<li><code>int read(char cbuf[], int off, int len)</code> 从第off位置开始读，读取len长度字符，放入数组b </li>
<li><code>long skip(long n)</code> 跳过指定个数的字符</li>
<li><code>int ready()</code> 是否可以读了</li>
<li><code>void close()</code> 关闭流，释放资源</li>
</ul>
</li>
<li><strong>Writer类</strong><ul>
<li><code>void write(int c)</code> 写入一个字符</li>
<li><code>void write(char cbuf[], int off, int len)</code> 将数组cbuf从off位置开始，长度为len的字符写入</li>
<li><code>void flush()</code> 强制刷新，将缓冲区的数据写入</li>
<li><code>void close()</code> 关闭流</li>
</ul>
</li>
</ul>
</li>
<li>字节流可以处理一切文件，而字符流只能处理文本</li>
</ul>
<h5 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h5><ul>
<li><p>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。</p>
<p>字符流一般用于处理纯文本类型的文件，不能处理图像视频等非文本文件。</p>
<p>字节流可以处理一切文件，而字符流只能处理纯文本文件。</p>
</li>
<li><p>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升大。</p>
<p>字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升小。</p>
</li>
</ul>
<h5 id="操作对象划分-文件、数组（内存）、管道、基本数据类型、缓冲、打印、对象序列化-x2F-反序列化、转换"><a href="#操作对象划分-文件、数组（内存）、管道、基本数据类型、缓冲、打印、对象序列化-x2F-反序列化、转换" class="headerlink" title="操作对象划分 - 文件、数组（内存）、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化、转换"></a>操作对象划分 - 文件、数组（内存）、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化、转换</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/io/shangtou-03.png" alt="img" style="zoom:33%;" />

<ul>
<li>文件<ul>
<li>直接操作文件的流</li>
<li>字节流（FileInputStream和FileOuputStream）和字符流（FileReader和FileWriter）</li>
</ul>
</li>
<li>数组（内存）<ul>
<li>文件读写操作可以使用文件流配合缓冲流</li>
<li>为了提升频繁读写文件时的效率，可用数组流&#x2F;内存流</li>
<li>数组流可以用于在内存中读写数据。<ul>
<li>优点是不需要创建临时文件，可以提高程序的效率。</li>
<li>缺点是只能存储有限数据量，存储数据量过大会导致内存溢出</li>
</ul>
</li>
</ul>
</li>
<li>管道<ul>
<li>Java中，通信双方必须在同一个进程中，也就是在同一个JVM中，管道为线程之间的通信提供了通信能力</li>
</ul>
</li>
<li>基本数据类型<ul>
<li>字节流读写基本数据类型DataInputStream和DataOutputStream</li>
</ul>
</li>
<li>缓冲<ul>
<li>为了减少程序和硬盘的交互，提升程序的效率，引入缓冲流（类名前缀带有Buffer）</li>
</ul>
</li>
<li>打印<ul>
<li>用于打印输出数据的类，包括 PrintStream和PrintWriter</li>
</ul>
</li>
<li>对象序列化&#x2F;反序列化<ul>
<li>序列化本质上是将一个Java对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程</li>
<li>ObjectInputStream和ObjectOutputStream</li>
</ul>
</li>
<li>转换<ul>
<li>InputStreamReader  字节流 -&gt; 字符流. 使用指定的字符集读取字节并将它们解码为字符</li>
<li>OutputStreamWriter 字符流 -&gt; 字节流. 将字符流输出对象变为字节流输出对象</li>
<li>使用转换流可以方便地在字节流和字符流之间进行转换。<ul>
<li>在进行文本文件读写时，通常使用字符流进行操作</li>
<li>在进行网络传输或与设备进行通信时，通常使用字节流进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-文件流-x3D-x3D"><a href="#x3D-x3D-文件流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;文件流&#x3D;&#x3D;"></a>&#x3D;&#x3D;文件流&#x3D;&#x3D;</h4><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p><code>java.io.File</code> 类专门对文件进行操作.只能对文件本身进行操作，不能对文件内容进行操作。操作内容必须借助输入输出流</p>
<p><code>File</code>类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作</p>
<h5 id="File构造方法"><a href="#File构造方法" class="headerlink" title="File构造方法"></a>File构造方法</h5><ul>
<li><code>File(String pathname)</code>  通过给定的<strong>路径</strong>来创建新的File实例</li>
<li><code>File(String parent, String child)</code>  从<strong>父路径（字符串）和子路径</strong>创建新的File实例</li>
<li><code>File(File parent, String child)</code>  从<strong>父路径（File）和子路径名字符串</strong>创建新的File实例</li>
</ul>
<p>File 类构造方法不会检验文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建</p>
<p>macOS路径使用正斜杠（<code>/</code>）作为路径分隔符，Windows路径使用反斜杠（<code>\</code>）作为路径分隔符。</p>
<p>Java 中提供了一个跨平台的方法来获取路径分隔符<code>File.separator</code>，会根据操作系统自动返回正确的路径分隔符</p>
<h5 id="File常用方法"><a href="#File常用方法" class="headerlink" title="File常用方法"></a>File常用方法</h5><ul>
<li>获取<ul>
<li><code>getAbsolutePath()</code> &#x2F;<code>getPath()</code>  绝对路径</li>
<li><code>getName()</code>  文件名或目录名。</li>
<li><code>length()</code>   文件长度，以字节为单位</li>
</ul>
</li>
<li>判断<ul>
<li><code>exists()</code> ：判断文件或目录是否存在</li>
<li><code>isDirectory()</code> ：判断是否为目录</li>
<li><code>isFile()</code> ：判断是否为文件</li>
</ul>
</li>
<li>创建 &#x2F; 删除<ul>
<li><code>createNewFile()</code>  文件不存在，创建一个空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li>
<li><code>delete()</code>  删除文件或目录。如果是目录，只有目录为空才能删除。</li>
<li><code>mkdir()</code>  只能创建一级目录。父目录不存在会创建失败。返回true&#x2F;false</li>
<li><code>mkdirs()</code> 可以创建多级目录。父目录不存在会一并创建。返回true&#x2F;false</li>
</ul>
</li>
<li>遍历<ul>
<li><code>String[] list()</code>  返回一个String数组，表示该File目录中的所有子文件或目录</li>
<li><code>File[] listFiles()</code> 返回一个File数组，表示该File目录中的所有子文件或目录</li>
</ul>
</li>
</ul>
<h5 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h5><ul>
<li><p>既可读文件，也可写文件</p>
</li>
<li><p>允许在文件中随机访问数据，如数据库系统</p>
</li>
<li><p>构造方法</p>
<ul>
<li><code>RandomAccessFile(File file / String name, String mode)</code>使用给定文件对象或文件名和访问模式创建</li>
</ul>
</li>
<li><p>访问模式</p>
<ul>
<li><p><code>&quot;r&quot;</code>   只读模式。调用结果对象的任何 write 方法都将导致IOException。</p>
</li>
<li><p><code>&quot;rw&quot;</code>  读写模式。如果文件不存在将被创建。</p>
</li>
<li><p><code>&quot;rws&quot;</code> 读写模式，并要求对<code>内容</code>或<code>元数据</code>的每个更新都被立即写入到底层存储设备。</p>
<p>​      这种模式是同步的，可以确保在系统崩溃时不会丢失数据。</p>
</li>
<li><p><code>&quot;rwd&quot;</code> 读写模式，仅要求对文件<code>内容</code>的更新被立即写入。<code>元数据可能会被延迟写入</code></p>
</li>
</ul>
</li>
<li><p><code>void seek(long pos)</code> 将文件指针设置到文件中的pos位置</p>
</li>
</ul>
<h5 id="Apache-FileUtils类"><a href="#Apache-FileUtils类" class="headerlink" title="Apache FileUtils类"></a>Apache FileUtils类</h5><p>Apache Commons IO库中的一个类，提供了更为方便的方法来操作文件或目录</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 复制</span>
<span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">copyFile</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">,</span> destFile<span class="token punctuation">)</span><span class="token punctuation">;</span>     	<span class="token comment">// 文件</span>
<span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">copyDirectory</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">,</span> destFile<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 目录</span>
<span class="token comment">// 删除</span>
<span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 移动</span>
<span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">moveFile</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">,</span> destFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 查询信息</span>
<span class="token class-name">Date</span> modifyTime <span class="token operator">=</span> <span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">lastModified</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">sizeOf</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> extension <span class="token operator">=</span> <span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Hutool-FileUtil类"><a href="#Hutool-FileUtil类" class="headerlink" title="Hutool FileUtil类"></a>Hutool FileUtil类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 复制</span>
<span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">copyFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 移动</span>
<span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 删除</span>
<span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 重命名</span>
<span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"FileUtilDemo3.java"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// readLines</span>
<span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">readLines</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-字节流-x3D-x3D"><a href="#x3D-x3D-字节流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字节流&#x3D;&#x3D;"></a>&#x3D;&#x3D;字节流&#x3D;&#x3D;</h4><h5 id="字节输出流（OutputStream）"><a href="#字节输出流（OutputStream）" class="headerlink" title="字节输出流（OutputStream）"></a>字节输出流（OutputStream）</h5><p><code>java.io.OutputStream</code>是<strong>字节输出流</strong>的<strong>超类</strong>（父类），它定义的一些共性方法：</p>
<ul>
<li><code>close()</code> ：关闭此输出流并释放与此流相关联的系统资源</li>
<li><code>flush()</code> ：刷新此输出流并强制缓冲区的字节被写入到目的地</li>
<li><code>write(byte[] b)</code>：将 b.length个字节从指定的字节数组写入此输出流 </li>
<li><code>write(byte[] b, int off, int len)</code> ：从指定的字节数组写入len字节到此输出流，从偏移量off开始</li>
</ul>
<h5 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>；
<span class="token comment">// true表示追加append，缺省默认false覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="字节输入流（InputStream）"><a href="#字节输入流（InputStream）" class="headerlink" title="字节输入流（InputStream）"></a>字节输入流（InputStream）</h5><p><code>java.io.InputStream</code> 是<strong>字节输入流</strong>的<strong>超类</strong>（父类），它的一些共性方法：</p>
<ul>
<li><code>close()</code> ：关闭此输入流并释放与此流相关的系统资源。</li>
<li><code>int read()</code>： 从输入流读取数据的下一个字节。</li>
<li><code>read(byte[] b)</code>： 该方法返回的int值代表的是读取了多少个字节，读取不到返回-1</li>
</ul>
<h5 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h5><h5 id="字节流解决中文乱码问题"><a href="#字节流解决中文乱码问题" class="headerlink" title="字节流解决中文乱码问题"></a>字节流解决中文乱码问题</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用 new String(byte bytes[], int offset, int length) 将字节流转换为字符串</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileInputStream</span> inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// String类的构造方法有解码功能</span>
<span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">byte</span> bytes<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">checkBounds</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token class-name">StringCoding</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 默认UTF-8编码解码</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Charset</span> <span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultCharset <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                defaultCharset <span class="token operator">=</span> cs<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                defaultCharset <span class="token operator">=</span> <span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> defaultCharset<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">decode</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ba<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">String</span> csn <span class="token operator">=</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// use charset name decode() variant which provides caching.</span>
        <span class="token keyword">return</span> <span class="token function">decode</span><span class="token punctuation">(</span>csn<span class="token punctuation">,</span> ba<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">warnUnsupportedCharset</span><span class="token punctuation">(</span>csn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="x3D-x3D-字符流-x3D-x3D"><a href="#x3D-x3D-字符流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;字符流&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符流&#x3D;&#x3D;</h4><p>字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息</p>
<p><strong>字符流 &#x3D; 字节流 + 编码表</strong></p>
<img src="https://cdn.tobebetterjavaer.com/stutymore/reader-writer-20230320164938.png" alt="img" style="zoom:50%;" />

<h5 id="字符输入流-Reader"><a href="#字符输入流-Reader" class="headerlink" title="字符输入流(Reader)"></a>字符输入流(Reader)</h5><p><code>java.io.Reader</code>是<strong>字符输入流</strong>的<strong>超类</strong>（父类），它定义了字符输入流的一些共性方法：</p>
<ul>
<li><p><code>close()</code>：关闭此流并释放与此流相关的系统资源。</p>
</li>
<li><p><code>read()</code>：从输入流读取一个字符。</p>
</li>
<li><p><code>read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p>
</li>
</ul>
<h5 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h5><p>FileReader实现AutoCloseable 接口，因此可使用<a target="_blank" rel="noopener" href="https://javabetter.cn/exception/try-with-resources.html">try-with-resources</a>语句自动关闭资源，避免了手动关闭资源</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">File</span> textFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"docs/约定.md"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 给一个 FileReader 的示例</span>
<span class="token comment">// try-with-resources FileReader</span>
<span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">FileReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>textFile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// read(char[] cbuf)</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="字符输出流（Writer）"><a href="#字符输出流（Writer）" class="headerlink" title="字符输出流（Writer）"></a>字符输出流（Writer）</h5><p><code>java.io.Writer</code> 是<strong>字符输出流</strong>类的<strong>超类</strong>（父类），可以将指定的字符信息写入到目的地，它定义的一些共性方法：</p>
<ul>
<li><code>write(int c)</code> 写入单个字节</li>
<li><code>write(char[] cbuf)</code> 写入字符数组</li>
<li><code>write(char[] cbuf, int off, int len)</code> 写入字符数组的一部分，off为开始索引，len为字符个数</li>
<li><code>write(String str)</code> 写入字符串</li>
<li><code>write(String str, int off, int len)</code> 写入字符串某一部分，off 指定起始位置，len 指定长度</li>
<li><code>flush()</code> 刷新该流的缓冲</li>
<li><code>close()</code> 关闭此流，但要先刷新它</li>
</ul>
<h5 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h5><p>FileWriter内置了缓冲区ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中</p>
<p><code>flush</code> ：刷新缓冲区，流对象可以继续使用</p>
<p><code>close</code> ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了</p>
<h5 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h5><p>实际开发中建议使用<code>try...catch...finally</code>代码块处理异常部分</p>
<p>或者直接使用<code>try-with-resources</code>的方式</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
  try-with-resources会在try块执行完毕后自动关闭FileWriter对象 fw，不需要手动关闭流。
  如果在try块中发生了异常，也会自动关闭流并抛出异常。
  因此，使用try-with-resources可以让代码更加简洁、安全和易读
*/</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileWriter</span> fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 写出数据</span>
    fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-缓冲流-x3D-x3D"><a href="#x3D-x3D-缓冲流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;缓冲流&#x3D;&#x3D;"></a>&#x3D;&#x3D;缓冲流&#x3D;&#x3D;</h4><p>Java缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高I&#x2F;O操作的效率</p>
<p>缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的I&#x2F;O操作次数，提高系统的I&#x2F;O效率，从而提高程序的运行效率</p>
<h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ul>
<li><code>BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong></li>
<li><code>BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong></li>
</ul>
<p>传统的Java IO是阻塞模式。字节缓冲流为解决此问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间</strong></p>
<ul>
<li>减少系统调用次数</li>
<li>减少磁盘读写次数</li>
<li>提高数据传输效率</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// BufferedInputStream 的 read 方法</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 如果当前位置已经到达缓冲区末尾</span>
        <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 填充缓冲区</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> count<span class="token punctuation">)</span>   <span class="token comment">// 如果填充后仍然到达缓冲区末尾，说明已经读取完毕</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 返回 -1 表示已经读取完毕</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">getBufIfOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span> <span class="token comment">// 返回当前位置的字节，并将位置加 1</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// BufferedOutputStream 的 write(byte b[], int off, int len) 方法</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">>=</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果写入的字节数大于等于缓冲区长度</span>
        <span class="token comment">/* 如果请求的长度超过了输出缓冲区的大小，
           先刷新缓冲区，然后直接将数据写入。
           这样可以避免缓冲流级联时的问题。*/</span>
        <span class="token function">flushBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 先刷新缓冲区</span>
        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接将数据写入输出流</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> buf<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果写入的字节数大于空余空间</span>
        <span class="token function">flushBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 先刷新缓冲区</span>
    <span class="token punctuation">&#125;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> off<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数据拷贝到缓冲区中</span>
    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>                             <span class="token comment">// 更新计数器</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><ul>
<li><code>BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li>
<li><code>BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li>
</ul>
<p>字符缓冲流的基本方法与普通字符流调用方式一致。<strong>特有</strong>的方法。</p>
<ul>
<li>BufferedReader：<code>String readLine()</code>: <strong>读一行数据</strong>，读取到最后返回null</li>
<li>BufferedWriter：<code>newLine()</code>: <strong>换行</strong>，由系统定义换行符</li>
</ul>
<h4 id="x3D-x3D-转换流-x3D-x3D"><a href="#x3D-x3D-转换流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;转换流&#x3D;&#x3D;"></a>&#x3D;&#x3D;转换流&#x3D;&#x3D;</h4><p>转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。解决乱码问题。</p>
<h5 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h5><p><code>java.io.InputStreamReader</code> 是Reader类的子类。作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换</p>
<h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h5><p><code>java.io.OutputStreamWriter</code> 是 Writer的子类，是将字符流转换为字节流，是字符流到字节流的桥梁</p>
<p>通常为了提高读写效率，我们会在转换流上再加一层缓冲流</p>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。</p>
<h4 id="x3D-x3D-序列流-序列化和反序列化-x3D-x3D"><a href="#x3D-x3D-序列流-序列化和反序列化-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;序列流(序列化和反序列化)&#x3D;&#x3D;"></a>&#x3D;&#x3D;序列流(序列化和反序列化)&#x3D;&#x3D;</h4><p>序列化是指将对象转换字节序列（包含<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息），以便网络传输或保存到文件中，或者在程序之间传递</p>
<p>反序列化是指将一个字节序列转换为一个对象，以便在程序中使用</p>
<p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现<code>java.io.Serializable</code> 接口，否则会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用<code>transient</code>进行修饰。</li>
</ul>
<h5 id="ObjectOutputSream"><a href="#ObjectOutputSream" class="headerlink" title="ObjectOutputSream"></a>ObjectOutputSream</h5><p><code>java.io.ObjectOutputStream</code>继承自OutputStream类，可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 构造方法接收一个OutputStream对象作为参数，用于将序列化后的字节序列输出到指定的输出流中</span>
<span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token class-name">OutputStream</span> out<span class="token punctuation">)</span>；
    
<span class="token comment">// ObjectOutputStream类中用于将对象序列化成字节序列并输出到输出流中的方法，</span>
<span class="token comment">// 可以处理对象之间的引用关系、继承关系、静态字段和transient字段</span>
writeObject <span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="ObjectInputSream"><a href="#ObjectInputSream" class="headerlink" title="ObjectInputSream"></a>ObjectInputSream</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个指定InputStream的ObjectInputStream，用于从指定的文件输入流中读取对象并反序列化</span>
<span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> in<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h5><p>实际开发中，很少使用JDK自带的序列化和反序列化</p>
<ul>
<li>可移植性差：Java特有的，无法跨语言进行序列化和反序列化。</li>
<li>性能差：序列化后字节体积大，增加了传输&#x2F;保存成本。</li>
<li>安全问题：攻击者可以通过构造恶意数据来实现远程代码执行，从而对系统造成严重的安全威胁。</li>
</ul>
<p>Kryo是一个Java序列化和反序列化库，具有高性能、高效率和易于使用和扩展等特点，有效地解决了JDK自带序列化机制痛点</p>
<p>已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如 Hive、Storm）中广泛使用。</p>
<ul>
<li>pom.xml引入依赖</li>
<li>创建Kryo对象，并使用<code>register（）</code>方法将对象进行注册</li>
<li><code>writeObject()</code> 方法将 Java 对象序列化为二进制流</li>
<li><code>readObject()</code> 方法将二进制流反序列化为Java对象</li>
</ul>
<h4 id="x3D-x3D-序列接口Serailizable-x3D-x3D"><a href="#x3D-x3D-序列接口Serailizable-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;序列接口Serailizable&#x3D;&#x3D;"></a>&#x3D;&#x3D;序列接口Serailizable&#x3D;&#x3D;</h4><p><code>Serializable</code>接口定义为空，只起到标识作用，说明实现此接口对象是可被序列化，序列化反序列化的操作不需要由它完成</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token comment">// ObjectOutputStream的writeObject0()方法</span>
	<span class="token comment">// 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token function">writeString</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token function">writeArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token function">writeEnum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 如果对象不能被序列化，则抛出 NotSerializableException 异常</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>
        		cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> debugInfoStack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ObjectOutputStream序列化时依次调用       <code>writeObject()</code>→<code>writeObject0()</code>→<code>writeOrdinaryObject()</code>→<code>writeSerialData()</code></p>
<p>→<code>invokeWriteObject()</code>→<code>defaultWriteFields()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">defaultWriteFields</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">ObjectStreamClass</span> desc<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 获取对象的类，并检查是否可以进行默认的序列化</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cl <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">forClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    desc<span class="token punctuation">.</span><span class="token function">checkDefaultSerialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取对象的基本类型字段的数量，以及这些字段的值</span>
    <span class="token keyword">int</span> primDataSize <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getPrimDataSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    desc<span class="token punctuation">.</span><span class="token function">getPrimFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> primVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将基本类型字段的值写入输出流</span>
    bout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>primVals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> primDataSize<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取对象的非基本类型字段的值</span>
    <span class="token class-name">ObjectStreamField</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objVals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>desc<span class="token punctuation">.</span><span class="token function">getNumObjFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> numPrimFields <span class="token operator">=</span> fields<span class="token punctuation">.</span>length <span class="token operator">-</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    desc<span class="token punctuation">.</span><span class="token function">getObjFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> objVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环写入对象的非基本类型字段的值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 调用 writeObject0 方法将对象的非基本类型字段序列化写入输出流</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token function">writeObject0</span><span class="token punctuation">(</span>objVals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> fields<span class="token punctuation">[</span>numPrimFields <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">isUnshared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果在写入过程中出现异常，则将异常包装成 IOException 抛出</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>abortIOException <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                abortIOException <span class="token operator">=</span> ex<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ObjectInputStream反序列化时依次调用<code>readObject()</code>→<code>readObject0()</code>→<code>readOrdinaryObject()</code>→<code>readSerialData()</code>→<code>defaultReadFields()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">defaultReadFields</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">ObjectStreamClass</span> desc<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 获取对象的类，并检查对象是否属于该类</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cl <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">forClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cl <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> obj <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cl<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassCastException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取对象的基本类型字段的数量和值</span>
    <span class="token keyword">int</span> primDataSize <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getPrimDataSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>primVals <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> primVals<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> primDataSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        primVals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>primDataSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 从输入流中读取基本类型字段的值，并存储在 primVals 数组中</span>
    bin<span class="token punctuation">.</span><span class="token function">readFully</span><span class="token punctuation">(</span>primVals<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> primDataSize<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 将 primVals 数组中的基本类型字段的值设置到对象的相应字段中</span>
        desc<span class="token punctuation">.</span><span class="token function">setPrimFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> primVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取对象的非基本类型字段的数量和值</span>
    <span class="token keyword">int</span> objHandle <span class="token operator">=</span> passHandle<span class="token punctuation">;</span>
    <span class="token class-name">ObjectStreamField</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> desc<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objVals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>desc<span class="token punctuation">.</span><span class="token function">getNumObjFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> numPrimFields <span class="token operator">=</span> fields<span class="token punctuation">.</span>length <span class="token operator">-</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 循环读取对象的非基本类型字段的值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objVals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 调用 readObject0 方法读取对象的非基本类型字段的值</span>
        <span class="token class-name">ObjectStreamField</span> f <span class="token operator">=</span> fields<span class="token punctuation">[</span>numPrimFields <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        objVals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">readObject0</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">isUnshared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果该字段是一个引用字段，则将其标记为依赖该对象</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            handles<span class="token punctuation">.</span><span class="token function">markDependency</span><span class="token punctuation">(</span>objHandle<span class="token punctuation">,</span> passHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 将 objVals 数组中的非基本类型字段的值设置到对象的相应字段中</span>
        desc<span class="token punctuation">.</span><span class="token function">setObjFieldValues</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> objVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    passHandle <span class="token operator">=</span> objHandle<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>static</code>和<code>transient</code>修饰的字段是不会被序列化的</p>
<ul>
<li>序列化保存的是对象的状态，<code>static</code> 修饰的字段属于类的状态，因此序列化不保存<code>static</code>修饰的字段</li>
<li><code>transient</code>即临时。阻止字段被序列化。所修饰字段在被反序列化后，字段值被设为初始值</li>
</ul>
<h4 id="x3D-x3D-序列化接口Externalizable-x3D-x3D"><a href="#x3D-x3D-序列化接口Externalizable-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;序列化接口Externalizable&#x3D;&#x3D;"></a>&#x3D;&#x3D;序列化接口Externalizable&#x3D;&#x3D;</h4><p>实现 <code>Externalizable</code> 接口</p>
<ul>
<li>新增一个无参构造方法<ul>
<li>使用<code>Externalizable</code>进行反序列化时，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出异常</li>
</ul>
</li>
<li>新增两个方法<code>writeExternal()</code>和&#96;&#96;readExternal()<code>。实现</code>Externalizable&#96;接口所必须的</li>
</ul>
<h4 id="x3D-x3D-Externalizable和Serializable区别-x3D-x3D"><a href="#x3D-x3D-Externalizable和Serializable区别-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Externalizable和Serializable区别&#x3D;&#x3D;"></a>&#x3D;&#x3D;Externalizable和Serializable区别&#x3D;&#x3D;</h4><p>Externalizable和Serializable都是用于实现Java对象的序列化和反序列化的接口</p>
<ul>
<li><p>Serializable是Java标准库提供的接口，Externalizable是Serializable的子接口</p>
</li>
<li><p>Serializable接口不需要实现任何方法，只需要将需要序列化的类标记为Serializable即可</p>
<p>Externalizable接口需要实现writeExternal和readExternal两个方法</p>
</li>
<li><p>Externalizable提供了更高的序列化控制能力，可以序列过程中对对象进行自定义处理，如对敏感信息进行加密和解密</p>
</li>
</ul>
<h5 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h5><ul>
<li><strong>Java虚拟机是否允许反序列化，取决于类路径和功能代码是否一致，以及序列化ID是否一致</strong></li>
<li><code>serialVersionUID</code>被称为序列化ID，是决定Java对象能否反序列化成功的重要因子。反序列化时Java虚拟机会把字节流中的<code>serialVersionUID</code> 与被序列化类中的<code>serialVersionUID</code>进行比较，相同可以反序列化，否则就会抛出序列化版本不一致异常</li>
</ul>
<h4 id="x3D-x3D-transient关键字-x3D-x3D"><a href="#x3D-x3D-transient关键字-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;transient关键字&#x3D;&#x3D;"></a>&#x3D;&#x3D;transient关键字&#x3D;&#x3D;</h4><p>在Serializable中表示该成员变量不参与序列化和反序列化，在Externalizable中不起作用</p>
<p>一个类的有些字段需要序列化，有些字段不需要，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上<code>transient</code>关键字</p>
<p>被transient关键字修饰的成员变量在反序列化时会被自动初始化为默认值</p>
<h5 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>被transient修饰，成员变量不再是对象持久化的一部分。反序列化时自动初始化为默认值</p>
</li>
<li><p>transient关键字只能修饰字段，而不能修饰方法和类</p>
</li>
<li><p>一个静态变量（static关键字修饰）不管是否被transient修饰，均不能被序列化</p>
</li>
<li><p>Serializable接口所有的序列化将会自动进行，</p>
<p>Externalizable接口，则需要在writeExternal方法中指定要序列化的字段，与transient关键字修饰无关</p>
</li>
</ul>
<h4 id="x3D-x3D-打印流-x3D-x3D"><a href="#x3D-x3D-打印流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;打印流&#x3D;&#x3D;"></a>&#x3D;&#x3D;打印流&#x3D;&#x3D;</h4><p>打印流具有几个特点：</p>
<ul>
<li>可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。</li>
<li>可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。</li>
<li>可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录</li>
</ul>
<p>PrintStream类的常用方法包括：</p>
<ul>
<li><p><code>print()</code>：输出一个对象的字符串表示形式。</p>
</li>
<li><p><code>println()</code>：输出一个对象的字符串表示形式，并在末尾添加一个换行符。</p>
</li>
<li><p><code>printf()</code>：使用指定的格式字符串和参数输出格式化的字符串</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
转换说明符
	%s：输出一个字符串。
	%d 或 %i：输出一个十进制整数。
	%x 或 %X：输出一个十六进制整数，%x 输出小写字母，%X 输出大写字母。
	%f 或 %F：输出一个浮点数。
	%e 或 %E：输出一个科学计数法表示的浮点数，%e 输出小写字母 e，%E 输出大写字母 E。
	%g 或 %G：输出一个浮点数，自动选择 %f 或 %e/%E 格式输出。
	%c：输出一个字符。
	%b：输出一个布尔值。
	%h：输出一个哈希码（16进制）。
	%n：换行符
宽度修饰符
	用数字指定输出的最小宽度，如果输出的数据不足指定宽度，则在左侧或右侧填充空格或零。
精度修饰符
	用点号（.）和数字指定浮点数或字符串的精度，对于浮点数，指定小数点后的位数，对于字符串，指定输出的字符数。
对齐修饰符  指定输出的对齐方式
	减号（-）表示左对齐填充空格
	零号（0）表示右对齐并填充零
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="x3D-x3D-异常处理-x3D-x3D"><a href="#x3D-x3D-异常处理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;异常处理&#x3D;&#x3D;"></a>&#x3D;&#x3D;异常处理&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/studymore/gailan-20230326090207.png" alt="img" style="zoom:33%;" />

<p>checked异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示进行相应的操作；</p>
<p>unchecked异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出</p>
<h5 id="NoClassDefFoundError-和-ClassNotFoundException-有什么区别"><a href="#NoClassDefFoundError-和-ClassNotFoundException-有什么区别" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 有什么区别"></a>NoClassDefFoundError 和 ClassNotFoundException 有什么区别</h5><ul>
<li>NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。</li>
<li>ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了</li>
</ul>
<h5 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h5><ul>
<li>throws关键字用于声明异常，它的作用和try-catch相似；throw关键字用于显式地主动抛出异常</li>
<li>throws关键字后面跟的是异常的名字；throw 关键字后面跟的是异常的对象</li>
<li>throws关键字出现在方法签名上，throw关键字出现在方法体里。</li>
<li>throws关键字在声明异常的时候可以跟多个，用逗号隔开；throw关键字每次只能抛出一个异常</li>
</ul>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><p><code>finally</code></p>
<ul>
<li>finally块前面必须有try块，不要把finally块单独拉出来使用。编译器不允许这样做</li>
<li>finally块不是必选项，有try 块的时候不一定要finally块</li>
<li>如果finally块中的代码可能会发生异常，也应该使用try-catch进行包裹。</li>
<li>即便是try块中执行了return、break、continue这些跳转语句，finally块也会被执行</li>
</ul>
<h5 id="不执行finally的情况"><a href="#不执行finally的情况" class="headerlink" title="不执行finally的情况"></a>不执行finally的情况</h5><ul>
<li>遇到了死循环。</li>
<li>执行了<code>System. exit()</code></li>
</ul>
<h4 id="x3D-x3D-try-with-resources-x3D-x3D"><a href="#x3D-x3D-try-with-resources-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;try-with-resources&#x3D;&#x3D;"></a>&#x3D;&#x3D;try-with-resources&#x3D;&#x3D;</h4><p>想释放自定义资源的话，只要实现AutoCloseable接口，并提供<code>close()</code>方法即可</p>
<h4 id="x3D-x3D-异常处理的20个最佳实践-x3D-x3D"><a href="#x3D-x3D-异常处理的20个最佳实践-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;异常处理的20个最佳实践&#x3D;&#x3D;"></a>&#x3D;&#x3D;异常处理的20个最佳实践&#x3D;&#x3D;</h4><ol>
<li>尽量不要捕获RuntimeException</li>
<li>尽量使用try-with-resource关闭资源，禁止在try块中直接关闭资源</li>
<li>不要捕获Throwable。Throwable是exception和error的父类</li>
<li>不要省略异常信息的记录</li>
<li>不要记录了异常又抛出了异常</li>
<li>不要在finally块中使用return。try块中的return就将被覆盖</li>
<li>抛出具体定义的检查性异常而不是Exception</li>
<li>捕获具体的子类而不是捕获Exception类</li>
<li>自定义异常时不要丢失堆栈跟踪</li>
<li>finally块中不要抛出任何异常</li>
<li>不要在生产环境中使用<code>printStackTrace()</code></li>
<li>对于不打算处理的异常，直接使用try-finally，不用catch</li>
<li>记住早throw晚catch原则。在代码中尽可能早地抛出异常，以便在异常发生时能够及时地处理异常。同时，在catch 块中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常</li>
<li>只抛出和方法相关的异常</li>
<li>切勿在代码中使用异常来进行流程控制</li>
<li>尽早验证用户输入以在请求处理的早期捕获异常</li>
<li>一个异常只能包含在一个日志中</li>
<li>将所有相关信息尽可能地传递给异常</li>
<li>终止掉被中断线程</li>
<li>对于重复的try-catch使用模板方法</li>
</ol>
<h4 id="x3D-x3D-空指针-x3D-x3D"><a href="#x3D-x3D-空指针-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;空指针&#x3D;&#x3D;"></a>&#x3D;&#x3D;空指针&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/exception/npe-1.jpg" alt="img" style="zoom: 50%;" />

<h4 id="x3D-x3D-try-catch会影响性能吗-x3D-x3D"><a href="#x3D-x3D-try-catch会影响性能吗-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;try-catch会影响性能吗&#x3D;&#x3D;"></a>&#x3D;&#x3D;try-catch会影响性能吗&#x3D;&#x3D;</h4><ol>
<li><code>try-catch</code>相比较没<code>try-catch</code>确实有一定的性能影响，但是旨在不推荐我们用 <code>try-catch</code> 来代替正常能不用 <code>try-catch</code>的实现，而不是不让用try-catch&#96;。</li>
<li>for循环内用<code>try-catch</code> 和用<code>try-catch</code> 包裹整个for循环性能差不多，但是其实两者本质上是业务处理方式的不同，跟性能扯不上关系，关键看业务流程处理。</li>
<li>虽然知道<code>try-catch</code>会有性能影响，但是业务上不需要避讳其使用，业务实现优先（非特殊情况下性能都是其次，有意识地避免大范围的<code>try-catch</code>，只catch 需要的部分即可（没把握全catch 也行，代码安全执行第一）</li>
</ol>
<hr>
<h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="x3D-x3D-Scanner工具类-x3D-x3D"><a href="#x3D-x3D-Scanner工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Scanner工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Scanner工具类&#x3D;&#x3D;</h4><p>Java的Scanner类是一个方便在控制台扫描用户输入的工具类，也可以扫描文件内容（扫描文件可以通过文件流来完成）</p>
<p>提供了多种方法来读取不同类型的数据<code>next()</code>, <code>nextInt()</code>, <code>nextLine()</code>, <code>nextDouble()</code> 等</p>
<p>可以通过 <code>useDelimiter()</code> 方法设置分隔符，通过 <code>findInLine()</code>, <code>findWithinHorizon()</code> 查找匹配项等</p>
<h4 id="x3D-x3D-Arrays工具类-x3D-x3D"><a href="#x3D-x3D-Arrays工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Arrays工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Arrays工具类&#x3D;&#x3D;</h4><p>提供了操作数组的静态方法可供直接调用</p>
<ul>
<li>创建数组<ul>
<li><code>copyOf()</code> 复制指定的数组，截取或用null填充</li>
<li><code>copyOfRange()</code> 复制指定范围内的数组到一个新的数组</li>
<li><code>fill()</code> 对数组进行填充</li>
</ul>
</li>
<li>比较数组<ul>
<li><code>equals()</code> 判断两个数组是否相等</li>
</ul>
</li>
<li>数组排序<ul>
<li><code>sort()</code> 对数组进行排序</li>
<li>基本数据类型按双轴快速排序，引用数据类型按TimSort排序，使用了Peter McIlroy的“乐观排序和信息理论复杂性”中的技术</li>
</ul>
</li>
<li>数组检索<ul>
<li><code>binarySearch()</code> 二分查找</li>
</ul>
</li>
<li>数组转流<ul>
<li><code>stream()</code> 将数组转换成流</li>
</ul>
</li>
<li>打印数组<ul>
<li><code>Arrays.toString()</code></li>
</ul>
</li>
<li>数组转List<ul>
<li><code>Arrays.asList()</code> 返回&#96;&#96;java.util.Arrays.ArrayList<code>，并不是</code>java.util.ArrayList&#96;，它的长度是固定的，无法进行元素的删除或者添加</li>
</ul>
</li>
<li><code>setAll()</code><ul>
<li>为新数组填充基于数组索引的新元素</li>
</ul>
</li>
<li><code>parallelPrefix()</code><ul>
<li>通过遍历数组中的元素，将当前下标位置上元素与之前下标元素进行操作，将操作后结果覆盖当前下标位置上元素</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-StringUtils工具类-x3D-x3D"><a href="#x3D-x3D-StringUtils工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;StringUtils工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;StringUtils工具类&#x3D;&#x3D;</h4><p><code>org.apache.commons.lang3</code>包下的<code>StringUtils</code>工具类</p>
<ul>
<li>字符串判空<ul>
<li><code>isEmpty</code>、<code>isNotEmpty</code>、<code>isBlank</code>和<code>isNotBlank</code></li>
</ul>
</li>
<li>分隔字符串<ul>
<li><code>split</code> 避免直接使用String类的split方法可能会出现空指针异常</li>
</ul>
</li>
<li>判断是否纯数字 <code>isNumeric</code></li>
<li>将集合拼接成字符串 <code>join</code></li>
<li><code>equals(String str1, String str2)</code>：比较两个字符串是否相等</li>
<li><code>equalsIgnoreCase(String str1, String str2)</code>：比较两个字符串是否相等，忽略大小写</li>
<li><code>startsWith(String str, String prefix)</code>：检查字符串是否以指定的前缀开头</li>
<li><code>endsWith(String str, String suffix)</code>：检查字符串是否以指定的后缀结尾</li>
<li><code>contains(String str, CharSequence seq)</code>：检查字符串是否包含指定的字符序列</li>
<li><code>capitalize(String str)</code>：将字符串的第一个字符转换为大写。</li>
<li><code>uncapitalize(String str)</code>：将字符串的第一个字符转换为小写</li>
</ul>
<h4 id="x3D-x3D-Objects工具类-x3D-x3D"><a href="#x3D-x3D-Objects工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Objects工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Objects工具类&#x3D;&#x3D;</h4><p>Objects类的主要目的是降低代码中的空指针异常(NullPointerException) 风险，同时提供一些非常实用的方法</p>
<ul>
<li><code>isNull()</code> 判断对象是否为空  <code>nonNull()</code> 判断对象是否不为空</li>
<li><code>requireNonNull()</code> 对象为空时，抛出空指针异常</li>
<li><code>Objects.equals()</code> 可以处理null值比较，不会抛出空指针异常。但依赖于被比较对象的<code>equals()</code>方法实现</li>
<li><code>hashCode()</code> 获取某个对象的hashCode</li>
<li><code>compare()</code> 比较两个对象，通常用于自定义排序</li>
<li><code>deepEquals()</code> 比较两个数组类型的对象，当对象是非数组的话行为和<code>equals()</code>一致</li>
</ul>
<h4 id="x3D-x3D-Collections工具类-x3D-x3D"><a href="#x3D-x3D-Collections工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Collections工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Collections工具类&#x3D;&#x3D;</h4><p>JDK提供的一个工具类，位于<code>java.util</code>包</p>
<ul>
<li>排序<ul>
<li><code>reverse(List list)</code>：反转顺序</li>
<li><code>shuffle(List list)</code>：洗牌，将顺序打乱</li>
<li><code>sort(List list)</code>：自然升序</li>
<li><code>sort(List list, Comparator c)</code>：按照自定义的比较器排序</li>
<li><code>swap(List list, int i, int j)</code>：将 i 和 j 位置的元素交换位置</li>
</ul>
</li>
<li>查找<ul>
<li><code>binarySearch(List list, Object key)</code>：二分查找法</li>
<li><code>max(Collection coll)</code>：返回最大元素</li>
<li><code>max(Collection coll, Comparator comp)</code>：根据自定义比较器，返回最大元素</li>
<li><code>min(Collection coll)</code>：返回最小元素</li>
<li><code>min(Collection coll, Comparator comp)</code>：根据自定义比较器，返回最小元素</li>
<li><code>fill(List list, Object obj)</code>：使用指定对象填充</li>
<li><code>frequency(Collection c, Object o)</code>：返回指定对象出现的次数</li>
</ul>
</li>
<li>同步控制<ul>
<li>提供了多个<code>synchronizedXxx()</code>方法，返回一个同步对象，从而解决多线程中访问集合时的安全问题</li>
<li>已废弃。正确的做法是使用并发包下的<code>CopyOnWriteArrayList</code>、<code>ConcurrentHashMap</code></li>
</ul>
</li>
<li>不可变集合<ul>
<li><code>emptyXxx()</code>：制造一个空的不可变集合</li>
<li><code>singletonXxx()</code>：制造一个只有一个元素的不可变集合</li>
<li><code>unmodifiableXxx()</code>：为指定集合制作一个不可变集合</li>
</ul>
</li>
<li><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code> 往集合中添加元素</li>
<li><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code>   判断两个集合是否没有交集</li>
</ul>
<h5 id="CollectionUtils：Spring和Apache都有提供的集合工具类"><a href="#CollectionUtils：Spring和Apache都有提供的集合工具类" class="headerlink" title="CollectionUtils：Spring和Apache都有提供的集合工具类"></a>CollectionUtils：Spring和Apache都有提供的集合工具类</h5><ul>
<li><code>isEmpty</code>判断集合是否为空，<code>isNotEmpty</code>判断集合不为空</li>
<li><code>union()</code>并集 <code>intersection()</code>交集 <code>disjunction()</code>补集 <code>subtract()</code>差集</li>
</ul>
<h4 id="x3D-x3D-Hutool工具类-x3D-x3D"><a href="#x3D-x3D-Hutool工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Hutool工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Hutool工具类&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-02.png" alt="img" style="zoom:33%;" />

<h4 id="x3D-x3D-Guava工具类-x3D-x3D"><a href="#x3D-x3D-Guava工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Guava工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Guava工具类&#x3D;&#x3D;</h4><p>Google公司开源的Java开发核心库</p>
<h4 id="x3D-x3D-其他常用工具类-x3D-x3D"><a href="#x3D-x3D-其他常用工具类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;其他常用工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;其他常用工具类&#x3D;&#x3D;</h4><h5 id="IpUtil：获取本机Ip"><a href="#IpUtil：获取本机Ip" class="headerlink" title="IpUtil：获取本机Ip"></a>IpUtil：获取本机Ip</h5><p>IPUtil 类中定义了两个方法，分别是 <code>getLocalIpByNetcard()</code> 和 <code>getLocalIP()</code>。前者是获取本机的内网 IPv4 地址，避免了返回 127.0.0.1 的问题。后者是获取本地主机地址，如果本机有多个 IP 地址，则可能返回其中的任意一个</p>
<h5 id="MDC：一个线程安全的参数传递工具类"><a href="#MDC：一个线程安全的参数传递工具类" class="headerlink" title="MDC：一个线程安全的参数传递工具类"></a>MDC：一个线程安全的参数传递工具类</h5><p><code>MDC</code>是<a target="_blank" rel="noopener" href="https://javabetter.cn/gongju/slf4j.html"><code>org.slf4j</code></a>包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。MDC的底层是用了<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html"><code>ThreadLocal</code></a> 来保存数据的。可以用它传递参数.</p>
<p>能使用MDC保存参数的根本原因是，用户请求到应用服务器，Tomcat 会从线程池中分配一个线程去处理该请求。</p>
<p>该请求的整个过程中，保存到MDC的ThreadLocal中的参数是该线程独享的，所以不会有线程安全问题。</p>
<h5 id="spring的org-springframework-util包下的ClassUtils类"><a href="#spring的org-springframework-util包下的ClassUtils类" class="headerlink" title="spring的org.springframework.util包下的ClassUtils类"></a>spring的<code>org.springframework.util</code>包下的<code>ClassUtils</code>类</h5><ul>
<li>获取对象的所有接口  <code>getAllInterfaces</code></li>
<li>获取某个类的包名    <code>getPackageName</code></li>
<li>判断某个类是否内部类 <code>isInnerClass</code></li>
<li>判断对象是否代理对象 <code>isCglibProxy</code></li>
</ul>
<h5 id="spring的org-springframework-beans包下的BeanUtils类"><a href="#spring的org-springframework-beans包下的BeanUtils类" class="headerlink" title="spring的org.springframework.beans包下的BeanUtils类"></a>spring的<code>org.springframework.beans</code>包下的<code>BeanUtils</code>类</h5><ul>
<li>拷贝对象属性  <code>copyProperties</code></li>
<li>反射实例化类  <code>instantiateClass</code></li>
<li>获取指定方法  <code>findDeclaredMethod</code></li>
<li>获取方法参数  <code>findPropertyForMethod</code></li>
</ul>
<h5 id="spring的org-springframework-util包下的ReflectionUtils类"><a href="#spring的org-springframework-util包下的ReflectionUtils类" class="headerlink" title="spring的org.springframework.util包下的ReflectionUtils类"></a>spring的<code>org.springframework.util</code>包下的<code>ReflectionUtils</code>类</h5><ul>
<li>获取方法  <code>findMethod</code></li>
<li>获取字段  <code>findField</code></li>
<li>执行方法  <code>invokeMethod</code></li>
<li>判断字段是否常量  <code>isPublicStaticFinal</code></li>
<li>判断是否equals方法  <code>isEqualsMethod</code></li>
</ul>
<hr>
<h3 id="Java新特性"><a href="#Java新特性" class="headerlink" title="Java新特性"></a>Java新特性</h3><h4 id="x3D-x3D-Stream流-x3D-x3D"><a href="#x3D-x3D-Stream流-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Stream流&#x3D;&#x3D;"></a>&#x3D;&#x3D;Stream流&#x3D;&#x3D;</h4><h5 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h5><ul>
<li>数组 <code>Arrays.stream()</code> 或者 <code>Stream.of()</code><ul>
<li><code>of()</code>方法内部其实调用了<code>Arrays.stream()</code>方法</li>
</ul>
</li>
<li>集合 <code>stream()</code>.该方法已经添加到 Collection 接口中</li>
<li>集合还可以调用<code>parallelStream()</code>方法创建并发流，默认使用的是<code>ForkJoinPool.commonPool()</code>线程池。</li>
</ul>
<h5 id="操作流"><a href="#操作流" class="headerlink" title="操作流"></a>操作流</h5><ul>
<li>过滤<ul>
<li><code>filter()</code> 从流中筛选出元素。方法接收的是一个Predicate（Java 8新增的一个函数式接口，接受一个输入参数返回一个布尔值结果）类型的参数，因此可以直接将一个Lambda表达式传递给该方法</li>
<li><code>forEach()</code> 方法接收的是一个Consumer（Java 8 新增的一个函数式接口，接受一个输入参数并且无返回的操作）类型的参数</li>
</ul>
</li>
<li>映射<ul>
<li><code>map() </code> 方法接收的是一个Function（Java 8 新增的一个函数式接口，接受一个输入参数T，返回一个结果 R）类型的参数。通过某种操作把一个流中的元素转化成新的流中的元素</li>
</ul>
</li>
<li>匹配<ul>
<li><code>anyMatch()</code> 只要有一个元素匹配传入的条件，返回true。</li>
<li><code>allMatch()</code> 只有有一个元素不匹配传入的条件，返回false；如果全部匹配，则返回true</li>
<li><code>noneMatch()</code> 只要有一个元素匹配传入的条件，返回false；如果全部不匹配，则返回true</li>
</ul>
</li>
<li>组合<ul>
<li><code>reduce()</code> 主要作用是把 Stream中的元素组合起来<ul>
<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> 运算规则；返回Optional</li>
<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> T类型起始值，运算规则；返回T类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p>把流转成集合或者数组</p>
<p><code>toArray()</code> <code>collect()</code>  <code>map()</code> <code>toList()</code> <code>toCollection()</code></p>
<h4 id="x3D-x3D-Optional-x3D-x3D"><a href="#x3D-x3D-Optional-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Optional&#x3D;&#x3D;"></a>&#x3D;&#x3D;Optional&#x3D;&#x3D;</h4><p>Optional可以解决NullPointerException（NPE）问题</p>
<h5 id="创建Optional对象"><a href="#创建Optional对象" class="headerlink" title="创建Optional对象"></a>创建Optional对象</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建空的Optional对象</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> empty <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建非空的Optional对象</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> opt <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个即可空又可非空的Optional对象</span>
<span class="token comment">/*
	ofNullable() 方法内部有一个三元表达式，参数为null返回私有常量 EMPTY；
	否则使用new关键字创建了新的Optional对象——不会再抛出NPE异常
*/</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> optOrNull <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="判断值是否存在"><a href="#判断值是否存在" class="headerlink" title="判断值是否存在"></a>判断值是否存在</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 判断一个Optional对象是否存在，存在返回true，否则返回false</span>
<span class="token comment">// 取代了obj != null的判断</span>
<span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>； 
<span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>； <span class="token comment">// !isPresent()；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="允许使用函数式编程执行代码"><a href="#允许使用函数式编程执行代码" class="headerlink" title="允许使用函数式编程执行代码"></a>允许使用函数式编程执行代码</h5><ul>
<li><p><code>ifPresent()</code></p>
</li>
<li><p><code>ifPresentOrElse(action, emptyAction)</code></p>
</li>
</ul>
<h5 id="设置（获取）默认值"><a href="#设置（获取）默认值" class="headerlink" title="设置（获取）默认值"></a>设置（获取）默认值</h5><ul>
<li><code>orElse()</code> 方法用于返回包裹在Optional对象中的值，值不为null则返回；否则返回默认值。参数类型和值类型一致</li>
<li><code>orElseGet()</code>  与orElse()方法类似，但参数类型不同。值为null执行参数中的函数</li>
<li><code>get()</code> 若Optional对象值为null，该方法会抛出NoSuchElementException异常。不推荐使用</li>
</ul>
<h4 id="x3D-x3D-Lambda表达式-x3D-x3D"><a href="#x3D-x3D-Lambda表达式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;</h4><p>Lambda表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行</p>
<p>通过 <code>@FunctionalInterface</code> 标记的接口可以通过Lambda表达式创建实例</p>
<h5 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span> parameter<span class="token operator">-</span>list <span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span> expression<span class="token operator">-</span>or<span class="token operator">-</span>statements <span class="token punctuation">&#125;</span>
<span class="token comment">// () 中的 parameter-list 是以逗号分隔的参数。</span>
<span class="token comment">// 可以指定或不指定参数类型（编译器会根据上下文进行推断）。Java 11后，可以使用var关键字作为参数类型</span>

<span class="token comment">// -> 相当于Lambda的标识符</span>

<span class="token comment">// &#123;&#125; 中的 expression-or-statements为Lambda的主体，可以是一行语句，也可以多行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和匿名内部类一样，不要在 Lambda 表达式主体内对方法内的局部变量进行修改，否则编译也不会通过</p>
<p>Lambda表达式中使用且未在Lambda表达式中声明的变量必须声明为final或是effectively final的</p>
<h5 id="Lambda和this关键字"><a href="#Lambda和this关键字" class="headerlink" title="Lambda和this关键字"></a>Lambda和this关键字</h5><p>Lambda表达式并不会引入新的作用域，这一点和匿名内部类是不同的。Lambda表达式主体内使用的this关键字和其所在的类实例相同</p>
<h4 id="x3D-x3D-Java-14新特性-x3D-x3D"><a href="#x3D-x3D-Java-14新特性-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java 14新特性&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java 14新特性&#x3D;&#x3D;</h4><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewInstanceOf</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Object</span> str <span class="token operator">=</span> <span class="token string">"..."</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h5><p>类的不可变性</p>
<ul>
<li>于Records来说，一条Record就代表一个不变的状态。尽管它会提供诸如 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>、构造方法，以及字段的getter，但它无意替代可变对象的类（没有setter），以及Lombok提供的功能</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Writer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">record</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h5><p>支持return和函数式表达式</p>
<h5 id="Text-Blocks"><a href="#Text-Blocks" class="headerlink" title="Text Blocks"></a>Text Blocks</h5><p>前后三个英文双引号表示文本块避免多行大量字符串加号拼接</p>
<hr>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="x3D-x3D-计算机网络-x3D-x3D"><a href="#x3D-x3D-计算机网络-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;计算机网络&#x3D;&#x3D;"></a>&#x3D;&#x3D;计算机网络&#x3D;&#x3D;</h4><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><h5 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h5><h4 id="x3D-x3D-套接字Socket-x3D-x3D"><a href="#x3D-x3D-套接字Socket-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;套接字Socket&#x3D;&#x3D;"></a>&#x3D;&#x3D;套接字Socket&#x3D;&#x3D;</h4><p>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I&#x2F;O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合</p>
<h5 id="ping-amp-telnet"><a href="#ping-amp-telnet" class="headerlink" title="ping&amp;telnet"></a>ping&amp;telnet</h5><p>ping，一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。ping会向目标主机发出一个ICMP的请求回显数据包，并等待接收回显响应数据包</p>
<p>telnet，Internet远程登录服务的标准协议和主要方式，可以让本地登录到另一台远程计算机。telnet在格外重视安全的现代网络技术中并不受到重用。因为telnet是明文传输协议，用户所有内容（包括用户名和密码）都没有经过加密，安全隐患大</p>
<h5 id="Socket实例"><a href="#Socket实例" class="headerlink" title="Socket实例"></a>Socket实例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
socket<span class="token punctuation">.</span><span class="token function">setSoTimeout</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 单位为毫秒 设置建立超时时间</span>
<span class="token comment">// 通过java.net.Socket类的getInputStream()方法获取输入流</span>
<span class="token class-name">InputStream</span> is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token string">"gbk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">String</span> line <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="ServerSocket实例"><a href="#ServerSocket实例" class="headerlink" title="ServerSocket实例"></a>ServerSocket实例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ServerSocket</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 调用 ServerSocket 对象的 accept() 等待客户端套接字的连接请求。</span>
<span class="token comment">// 一旦监听到客户端套接字请求，就会返回一个表示连接已建立的Socket对象，可以从中获取到输入流和输出流</span>
<span class="token class-name">Socket</span> socket <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InputStream</span> is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">OutputStream</span> os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 向客户端发送消息</span>
<span class="token class-name">PrintWriter</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> <span class="token string">"gbk"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pw<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读取客户端信息</span>
<span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>done <span class="token operator">&amp;&amp;</span> scanner<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">String</span> line <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="为多个客户端服务"><a href="#为多个客户端服务" class="headerlink" title="为多个客户端服务"></a>为多个客户端服务</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ServerSocket</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              <span class="token comment">// 套接字处理程序</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">ServerSocket</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiThreadedServer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
        <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Server is listening on port "</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Client connected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">ClientHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
使用了一个 ClientHandler类，该类继承自Thread类。这使得每个客户端连接都可以在单独的线程中处理，从而允许服务器同时处理多个客户端连接。当一个新客户端连接到服务器时，服务器会创建一个新的ClientHandler对象，并使用start()方法启动线程。ClientHandler类的run()方法包含处理客户端请求的逻辑
*/</span>
<span class="token keyword">class</span> <span class="token class-name">ClientHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ClientHandler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">InputStream</span> input <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">OutputStream</span> output <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">PrintWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> line<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received: "</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
                writer<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Server: "</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Client disconnected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="DatagramSocket实例"><a href="#DatagramSocket实例" class="headerlink" title="DatagramSocket实例"></a>DatagramSocket实例</h5><p>DatagramSocket 类是Java中实现UDP协议的核心类。与基于TCP的Socket和ServerSocket类不同，DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP通常比TCP 更快，但不如TCP可靠</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 服务器端代码</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">DatagramPacket</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">DatagramSocket</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UDPServer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
        <span class="token class-name">DatagramSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Server is listening on port "</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 阻塞，直到收到一个数据包</span>
        serverSocket<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        serverSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 客户端代码</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UDPClient</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> hostname <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
        <span class="token class-name">InetAddress</span> address <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span>hostname<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">DatagramSocket</span> clientSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"Hello, server!"</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">,</span> address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 发送数据包</span>
        clientSocket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Message sent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        clientSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="x3D-x3D-用Socket实现一个HTTP服务器-x3D-x3D"><a href="#x3D-x3D-用Socket实现一个HTTP服务器-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;用Socket实现一个HTTP服务器&#x3D;&#x3D;"></a>&#x3D;&#x3D;用Socket实现一个HTTP服务器&#x3D;&#x3D;</h4><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><ul>
<li><p>HTTP请求消息</p>
<ul>
<li><p>请求行（Request Line）</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// HTTP方法 请求目标URL HTTP版本</span>
GET /index.html HTTP/<span class="token number">1.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>请求头（Request Headers）</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 一系列以键值对表示的元数据，用于描述请求的附加信息。每个请求头占一行，键和值之间用冒号（:）分隔</span>
Host<span class="token operator">:</span> www.tobebetterjavaer.com
User-Agent<span class="token operator">:</span> Mozilla/<span class="token number">5.0</span>
Accept<span class="token operator">:</span> text/html<span class="token punctuation">,</span>application/xhtml+xml<span class="token punctuation">,</span>application/xml;q=<span class="token number">0.9</span><span class="token punctuation">,</span>*<span class="token comment">/*;q=0.8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>空行（Empty Line）</p>
<p>请求头和请求体间有一个空行，表示请求头的结束</p>
</li>
<li><p>请求体（Request Body，可选）</p>
</li>
</ul>
</li>
<li><p>HTTP响应消息</p>
<ul>
<li>状态行（Status Line）</li>
<li>响应头（Response Headers）</li>
<li>响应体（Response Body）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="x3D-x3D-NIO-amp-OIO-x3D-x3D"><a href="#x3D-x3D-NIO-amp-OIO-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;NIO&amp;OIO&#x3D;&#x3D;"></a>&#x3D;&#x3D;NIO&amp;OIO&#x3D;&#x3D;</h4><img src="https://cdn.tobebetterjavaer.com/stutymore/nio-better-io-20230406180538.png" alt="img" style="zoom:33%;" />

<p>传统IO基于字节流或字符流进行文件读写，以及使用Socket和ServerSocket进行网络传输。</p>
<p>NIO使用通道Channel和缓冲区Buffer进行文件操作，以及使用SocketChannel和ServerSocketChannel进行网络传输</p>
<p>传统IO采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待I&#x2F;O操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。</p>
<p>NIO使用非阻塞模型，允许线程在等待I&#x2F;O时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道Channel上的I&#x2F;O事件，实现了更高的性能和可伸缩性</p>
<h5 id="NIO和OIO在操作文件时的差异"><a href="#NIO和OIO在操作文件时的差异" class="headerlink" title="NIO和OIO在操作文件时的差异"></a>NIO和OIO在操作文件时的差异</h5><h5 id="NIO和OIO在网络传输中的差异"><a href="#NIO和OIO在网络传输中的差异" class="headerlink" title="NIO和OIO在网络传输中的差异"></a>NIO和OIO在网络传输中的差异</h5><p>NIO的设计目标是解决传统I&#x2F;O（BIO，Blocking I&#x2F;O）在处理大量并发连接时的性能瓶颈。传统 I&#x2F;O 在网络通信中主要使用阻塞式 I&#x2F;O，为每个连接分配一个线程。当连接数量增加时，系统性能将受到严重影响，线程资源成为关键瓶颈。而 NIO 提供了非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用，可以在单个线程中处理多个并发连接，从而在网络传输中显著提高性能。</p>
<p>NIO在网络传输中优于传统I&#x2F;O的原因：</p>
<ul>
<li><p>①、NIO支持非阻塞I&#x2F;O，这意味着在执行I&#x2F;O操作时，线程不会被阻塞。使得网络传输中可以有效管理大量并发连接</p>
<p>操作文件时，优势不明显，因为文件读写通常不涉及大量并发操作。</p>
</li>
<li><p>②、NIO支持I&#x2F;O多路复用，一个线程可以同时监视多个通道（如套接字），在I&#x2F;O事件（如可读、可写）准备好时处理。这大大提高了网络传输中的性能，因为单个线程可以高效地管理多个并发连接。操作文件时该优势无法提现出来。</p>
</li>
<li><p>③、NIO提供了ByteBuffer类，可以高效地管理缓冲区。在网络传输中很重要，因为数据通常是以字节流的形式传输。操作文件的时候，虽然也有缓冲区，但优势仍然不够明显</p>
</li>
</ul>
<p>NIO网络编程</p>
<ul>
<li><p>ServerSocketChannel 类似于ServerSocket，表示服务器端套接字通道。它负责监听客户端连接请求，</p>
<p>可以设置为非阻塞模式，这意味着在等待客户端连接请求时不会阻塞线程。</p>
</li>
<li><p>SocketChannel 类似于Socket，表示客户端套接字通道。它负责与服务器端建立连接并进行数据的读写。SocketChannel也可以设置为非阻塞模式，在读写数据时不会阻塞线程</p>
</li>
<li><p>Selector是Java NIO中的一个关键组件，用于实现I&#x2F;O多路复用。它允许在单个线程中同时监控多个 ServerSocketChannel和SocketChannel，并通过SelectionKey标识关注的事件。当某个事件发生时，Selector 会将对应的SelectionKey 添加到已选择的键集合中。通过使用Selector，可以在单个线程中同时处理多个连接，从而有效地提高I&#x2F;O操作的性能，特别是在高并发场景下</p>
</li>
</ul>
<h5 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>传统I&#x2F;O采用阻塞式模型，线程在I&#x2F;O操作期间无法执行其他任务。</p>
<p>NIO非阻塞模型，允许线程在等待I&#x2F;O时执行其他任务，通过Selector监控多个ChannelI&#x2F;O事件，提高性能和可伸缩性</p>
</li>
<li><p>传统I&#x2F;O使用基于字节流或字符流的类进行文件读写。</p>
<p>NIO使用通道（Channel）和缓冲区（Buffer）进行文件操作，NIO在性能上的优势并不大。</p>
</li>
<li><p>传统I&#x2F;O使用Socket和ServerSocket进行网络传输，存在阻塞问题。</p>
<p>NIO 提供了SocketChannel和ServerSocketChannel，支持非阻塞网络传输，提高了并发处理能力</p>
</li>
<li><p><strong>IO 是面向流的处理，NIO 是面向块(缓冲区)的处理</strong></p>
</li>
<li><p>传统IO<strong>流是单向的</strong>。NIO通道<strong>读写是双向</strong>的</p>
</li>
</ul>
<h4 id="x3D-x3D-Java-IO与BIO、NIO-x3D-x3D"><a href="#x3D-x3D-Java-IO与BIO、NIO-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java IO与BIO、NIO&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java IO与BIO、NIO&#x3D;&#x3D;</h4><p>IO，是Input&#x2F;Output的简称，即输入&#x2F;输出。通常指数据在内存和外部存储器或其他周边设备之间的输入和输出</p>
<p>三种IO</p>
<ul>
<li><p>BIO</p>
<ul>
<li><p>BIO全称Block-IO一种<strong>同步且阻塞</strong>的通信模式。较传统的通信方式，模式简单，使用方便。</p>
<p>但并发处理能力低，通信耗时，依赖网速</p>
</li>
</ul>
</li>
<li><p>NIO</p>
<ul>
<li>Java NIO，Non-Block IO，Java SE 1.4版后针对网络传输效能优化的新功能。一种<strong>非阻塞同步</strong>的通信模式。</li>
</ul>
</li>
<li><p>AIO</p>
<ul>
<li><p>Java AIO，Asynchronous IO，<strong>异步非阻塞</strong>的IO。是一种非阻塞异步的通信模式</p>
<p>在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现</p>
</li>
</ul>
</li>
</ul>
<h5 id="三种IO的区别"><a href="#三种IO的区别" class="headerlink" title="三种IO的区别"></a>三种IO的区别</h5><ul>
<li><p><strong>BIO （Blocking I&#x2F;O） 同步阻塞I&#x2F;O模式</strong></p>
<ul>
<li><p>BIO方式适用于连接数目比较小且固定的架构，</p>
<p>这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解</p>
</li>
</ul>
</li>
<li><p><strong>NIO （New I&#x2F;O） 同步非阻塞模式</strong></p>
<ul>
<li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，</p>
<p>比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持</p>
</li>
</ul>
</li>
<li><p><strong>AIO （Asynchronous I&#x2F;O）：异步非阻塞I&#x2F;O模型</strong></p>
<ul>
<li><p>AIO 方式适用于连接数目多且连接比较长（重操作）的架构，</p>
<p>比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持</p>
</li>
</ul>
</li>
</ul>
<h5 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>BIO（Blocking I&#x2F;O） 采用阻塞式I&#x2F;O 模型，线程在执行I&#x2F;O操作时被阻塞，无法处理其他任务，</p>
<p>适用于连接数较少且稳定的场景。</p>
</li>
<li><p>NIO（New I&#x2F;O 或 Non-blocking I&#x2F;O） 使用非阻塞I&#x2F;O模型，线程在等待I&#x2F;O时可执行其他任务</p>
<p>通过Selector监控多个Channel上的事件，提高性能和可伸缩性，适用于高并发场景。</p>
</li>
<li><p>AIO（Asynchronous I&#x2F;O） 采用异步I&#x2F;O模型，线程发起I&#x2F;O请求后立即返回，</p>
<p>当I&#x2F;O操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景</p>
</li>
</ul>
<h4 id="x3D-x3D-NIO的Buffer和Channel-x3D-x3D"><a href="#x3D-x3D-NIO的Buffer和Channel-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;NIO的Buffer和Channel&#x3D;&#x3D;"></a>&#x3D;&#x3D;NIO的Buffer和Channel&#x3D;&#x3D;</h4><p>NIO<strong>通过Channel通道运输着存储数据的Buffer缓冲区实现数据处理</strong></p>
<h5 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h5><p>Buffer是缓冲区的抽象类。核心方法就是put和get</p>
<img src="https://cdn.tobebetterjavaer.com/stutymore/rumen-20230404152253.png" alt="img" style="zoom: 33%;" />

<p>Buffer类维护了4个核心变量来提供<strong>关于其所包含的数组信息</strong>。它们是：</p>
<ul>
<li>容量 Capacity <strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定且永远不能被改变(底层是数组)</li>
<li>上界 Limit <strong>缓冲区里的数据的总数</strong>，代表了当前缓冲区中一共有多少数据</li>
<li>位置 Position <strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的get()和put()函数更新</li>
<li>标记 Mark 一个备忘位置。<strong>用于记录上一次读写信息</strong></li>
</ul>
<p><code>flip()</code> <strong>改动position和limit的位置</strong></p>
<p><code>clear()</code> 清空缓冲区，数据没有真正被清空，只是被<strong>遗忘</strong></p>
<h5 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h5><p>Channel 通道<strong>只负责传输数据、不直接操作数据</strong></p>
<ul>
<li><p>文件通道 </p>
<ul>
<li><p>FileChannel</p>
<p>用于文件 I&#x2F;O 的通道，支持文件的读写和追加操作。FileChannel允许在文件的任意位置进行数据传输，支持文件锁定以及内存映射文件等高级功能。FileChannel无法设置为非阻塞模式，因此它只适用于阻塞式文件操作</p>
</li>
</ul>
</li>
<li><p>套接字通道 </p>
<ul>
<li><p>SocketChannel &#x2F; ServerSocketChannel</p>
<p>用于TCP套接字I&#x2F;O的通道。SocketChannel支持非阻塞模式，可以与Selector一起使用，实现高效的网络通信。SocketChannel允许连接到远程主机，进行数据传输</p>
</li>
<li><p>DatagramChannel</p>
<p>用于 UDP 套接字 I&#x2F;O 的通道。DatagramChannel 支持非阻塞模式，可以发送和接收数据报包，适用于无连接的、不可靠的网络通信。</p>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-Paths和Files-x3D-x3D"><a href="#x3D-x3D-Paths和Files-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Paths和Files&#x3D;&#x3D;"></a>&#x3D;&#x3D;Paths和Files&#x3D;&#x3D;</h4><p>Paths和Files在Java 7的时候引入，作为对<code>java.io.File</code>类的补充和改进</p>
<h5 id="Paths类"><a href="#Paths类" class="headerlink" title="Paths类"></a>Paths类</h5><h5 id="Files类"><a href="#Files类" class="headerlink" title="Files类"></a>Files类</h5><h4 id="x3D-x3D-Java-IO模型-x3D-x3D"><a href="#x3D-x3D-Java-IO模型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java IO模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java IO模型&#x3D;&#x3D;</h4><h5 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h5><p>阻塞I&#x2F;O（Blocking I&#x2F;O）：I&#x2F;O操作是阻塞的，即执行I&#x2F;O操作时，线程会被阻塞，直到操作完成。在阻塞I&#x2F;O模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I&#x2F;O 模型的性能较差</p>
<img src="https://cdn.tobebetterjavaer.com/stutymore/moxing-20230408110408.png" alt="img" style="zoom: 50%;" />

<p>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）：I&#x2F;O操作不会阻塞线程。当数据尚未准备好时，I&#x2F;O调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行I&#x2F;O操作。非阻塞I&#x2F;O模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理</p>
<img src="https://cdn.tobebetterjavaer.com/stutymore/moxing-20230408110433.png" alt="img" style="zoom:50%;" />

<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><img src="https://cdn.tobebetterjavaer.com/stutymore/moxing-20230408115158.png" alt="img" style="zoom:50%;" />

<p>I&#x2F;O多路复用（I&#x2F;O Multiplexing）模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个I&#x2F;O事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程</p>
<ul>
<li>select是 Unix系统中最早的 I&#x2F;O 多路复用技术。它允许一个线程同时监视多个文件描述符（如套接字），并等待某个文件描述符上的 I&#x2F;O 事件（如可读、可写或异常）。select的主要问题是性能受限，特别是在处理大量文件描述符时。因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。</li>
<li>poll是对select的改进。它使用一个文件描述符数组而不是位掩码表示文件描述符集。可以避免select的性能问题。然而，poll仍需遍历整个文件描述符数组以检查每个文件描述符的状态。因此在处理大量文件描述符时性能仍然受限。</li>
<li>epoll是Linux 中的一种高性能I&#x2F;O多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的I&#x2F;O事件发生时，内核会将该事件添加到事件表中。应用程序可以使用epoll_wait函数来获取已准备好的I&#x2F;O事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。</li>
</ul>
<p>在JavaNIO 中，I&#x2F;O多路复用主要通过 Selector 类实现。Selector 能够监控多个Channel上的I&#x2F;O事件，如连接、读取和写入。这使得一个线程可以处理多个并发连接，提高了程序的性能和可伸缩性。</p>
<h5 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h5><img src="https://cdn.tobebetterjavaer.com/stutymore/moxing-20230408115251.png" alt="img" style="zoom: 50%;" />

<p>信号驱动 I&#x2F;O（Signal-driven I&#x2F;O）模型中，应用程序可以向操作系统注册一个信号处理函数，当某个I&#x2F;O事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的I&#x2F;O事件。这种模型与非阻塞I&#x2F;O类似，也需要在应用程序级别进行事件管理和调度。</p>
<h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><img src="https://cdn.tobebetterjavaer.com/stutymore/moxing-20230408115328.png" alt="img" style="zoom:50%;" />

<p>异步I&#x2F;O（Asynchronous I&#x2F;O）模型与同步 I&#x2F;O模型的主要区别在于，异步I&#x2F;O操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待I&#x2F;O操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。</p>
<ul>
<li>同步：在执行I&#x2F;O操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步I&#x2F;O包括阻塞 I&#x2F;O、非阻塞I&#x2F;O和I&#x2F;O多路复用。</li>
<li>异步：在执行I&#x2F;O操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在I&#x2F;O操作进行时继续执行其他任务。异步I&#x2F;O模型包括信号驱动I&#x2F;O和异步I&#x2F;O。</li>
</ul>
<h5 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h5><p>IO模型主要有五种：阻塞 I&#x2F;O、非阻塞I&#x2F;O、多路复用、信号驱动和异步I&#x2F;O。</p>
<ul>
<li>阻塞I&#x2F;O：应用程序执行I&#x2F;O操作时，会一直等待数据传输完成，期间无法执行其他任务。</li>
<li>非阻塞I&#x2F;O：应用程序执行I&#x2F;O操作时，如果数据未准备好立即返回错误状态，不等待数据传输完成可执行其他任务。</li>
<li>多路复用：允许一个线程同时管理多个I&#x2F;O连接，适用于高并发低延迟高吞吐量场景，减少线程数量和上下文切换开销。</li>
<li>信号驱动：依赖信号通知应用程序I&#x2F;O事件，用于低并发低延迟低吞吐量场景，需为各I&#x2F;O事件创建信号、信号处理函数</li>
<li>异步I&#x2F;O：应用程序发起I&#x2F;O操作后，内核负责数据传输过程完成后通知应用程序。应用程序无需等待，可执行其他任务</li>
</ul>
<hr>
<h3 id="Java重要知识点"><a href="#Java重要知识点" class="headerlink" title="Java重要知识点"></a>Java重要知识点</h3><h4 id="x3D-x3D-Java命名规范-x3D-x3D"><a href="#x3D-x3D-Java命名规范-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java命名规范&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java命名规范&#x3D;&#x3D;</h4><ul>
<li><p>包</p>
<ul>
<li>小写</li>
<li>点分隔符间有且仅有一个自然语义单词</li>
<li>包名统一使用单数形式</li>
<li>域名反写</li>
</ul>
</li>
<li><p>类</p>
<ul>
<li>大写开头</li>
<li>名词</li>
<li>驼峰式命名UpperCamelCase风格<ul>
<li>抽象类 Abstract或Base开头</li>
<li>异常类 Exception结尾</li>
<li>测试类 Test结尾</li>
</ul>
</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li>大写开头</li>
<li>形容词<ul>
<li>实现 able-&gt;tor 或 Impl</li>
</ul>
</li>
</ul>
</li>
<li><p>字段和变量</p>
<ul>
<li>小写开头的驼峰式命名 upperCamelCase</li>
<li>POJO类boolean型变量不加is前缀，避免部分框架解析产生的序列化错误（如fastjson）</li>
<li>避免在子类和父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名</li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>大写</li>
<li>_连接</li>
<li>可包含数字，不以数字开头</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>小写开头的驼峰式风格</li>
<li>动词</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><p>均不以下划线或美元符号开始</p>
</li>
<li><p>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格</p>
</li>
<li><p>模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
</li>
<li><p>枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p>
<p>枚举其实就是特殊的常量类，且构造方法被默认强制是私有</p>
</li>
</ul>
</li>
</ul>
<h4 id="x3D-x3D-中文乱码问题及字符编码-x3D-x3D"><a href="#x3D-x3D-中文乱码问题及字符编码-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;中文乱码问题及字符编码&#x3D;&#x3D;"></a>&#x3D;&#x3D;中文乱码问题及字符编码&#x3D;&#x3D;</h4><h5 id="常见的字符编码"><a href="#常见的字符编码" class="headerlink" title="常见的字符编码"></a>常见的字符编码</h5><ul>
<li>ASCII<ul>
<li>局限在于只能显示 26 个基本拉丁字母、阿拉伯数字和英式标点符号</li>
</ul>
</li>
<li>Unicode 万国码、国际码、统一码、单一码<ul>
<li>UTF-8<ul>
<li>可变长度的编码方式</li>
</ul>
</li>
<li>UTF-16</li>
</ul>
</li>
<li>GB2312</li>
</ul>
<h4 id="x3D-x3D-拆箱和装箱-x3D-x3D"><a href="#x3D-x3D-拆箱和装箱-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;拆箱和装箱&#x3D;&#x3D;"></a>&#x3D;&#x3D;拆箱和装箱&#x3D;&#x3D;</h4><p>拆箱就是将包装类型对象转换为其对应的基本数据类型，装箱则是将基本数据类型转换为相应的包装类型对象</p>
<h5 id="包装类型和基本数据类型的区别"><a href="#包装类型和基本数据类型的区别" class="headerlink" title="包装类型和基本数据类型的区别"></a>包装类型和基本数据类型的区别</h5><ul>
<li><p><strong>包装类型可以为null，基本数据类型不可以</strong></p>
<p>数据库查询结果可能是null，如果使用基本数据类型，自动拆箱会抛出NullPointerException的异常</p>
</li>
<li><p><strong>包装类型可用于泛型，基本数据类型不可以</strong></p>
<p>泛型在编译时会进行类型擦除，最后只保留原始类型.原始类型只能是Object类及其子类:基本数据类型是例外</p>
</li>
<li><p><strong>基本数据类型比包装类型更高效</strong></p>
<ul>
<li>包装类型要存储对象和引用，需要占用更多的内存空间</li>
</ul>
</li>
<li><p><strong>两个包装类型的值可以相同，但却不相等</strong></p>
</li>
</ul>
<h5 id="自动拆箱和自动装箱"><a href="#自动拆箱和自动装箱" class="headerlink" title="自动拆箱和自动装箱"></a>自动拆箱和自动装箱</h5><p>自动装箱是通过 <code>Integer.valueOf()</code> 完成的；自动拆箱是通过 <code>Integer.intValue()</code> 完成的</p>
<p><strong>当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象</strong></p>
<h4 id="x3D-x3D-Java浅拷贝与深拷贝-x3D-x3D"><a href="#x3D-x3D-Java浅拷贝与深拷贝-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java浅拷贝与深拷贝&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java浅拷贝与深拷贝&#x3D;&#x3D;</h4><h5 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h5><p>浅拷贝和深拷贝都可以通过调用Object类的<code>clone()</code>方法来完成</p>
<p><code>clone()</code>方法是一个本地（<code>native</code>）方法，它的具体实现会交给 HotSpot 虚拟机，那就意味着虚拟机在运行该方法的时候，会将其替换为更高效的 C&#x2F;C++ 代码，进而调用操作系统去完成对象的克隆工作。Java 9后，该方法会被标注 <code>@HotSpotIntrinsicCandidate</code>注解，被该注解标注的方法在 HotSpot 虚拟机中会有一套高效的实现</p>
<p>实现Cloneable接口标记类可以执行clone()方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>浅拷贝克隆的对象中，引用类型的字段指向的是同一个，当改变任何一个对象，另外一个对象也会随之改变</p>
<p>深拷贝中的引用类型字段也会克隆一份，当改变任何一个对象，另外一个对象不会随之改变</p>
<p>通过<code>clone()</code>方法实现深拷贝要将所有的引用类型都重写<code>clone()</code>方法</p>
<h5 id="序列化-x2F-反序列化"><a href="#序列化-x2F-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h5><p>由于是序列化涉及到输入流和输出流的读写，在性能上要比HotSpot虚拟机实现的<code>clone()</code>方法差很多</p>
<h4 id="x3D-x3D-Java-hashCode方法解析-x3D-x3D"><a href="#x3D-x3D-Java-hashCode方法解析-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java hashCode方法解析&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java hashCode方法解析&#x3D;&#x3D;</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Object类包含hashCode()方法</span>
<span class="token comment">// Java 9后，hashCode() 方法被@HotSpotIntrinsicCandidate注解修饰，</span>
<span class="token comment">// 表明在HotSpot虚拟机中有基于CPU指令高效的实现</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Java中，<code>hashCode()</code>方法是定义在 <code>java.lang.Object</code> 类中的一个方法，该类是所有 Java 所有类的父类。因此，每个 Java 对象都可以调用 <code>hashCode()</code>方法。<code>hashCode()</code>方法主要用于支持哈希表（如 java.util.HashMap），这些数据结构使用哈希算法能实现快速查找、插入和删除操作。</p>
<p><code>hashCode()</code>方法的主要目的是返回一个整数，这个整数称为哈希码，它代表了对象在内存中的一种近似表示。哈希码用于将对象映射到哈希表中的一个特定的位置。两个相等的对象（根据 <a target="_blank" rel="noopener" href="https://javabetter.cn/string/equals.html"><code>equals()</code>方法比较</a>）应该具有相同的哈希码。然而，具有相同哈希码的两个对象并不一定相等</p>
<p>当你创建一个自定义类并覆盖<code>equals()</code>方法时，通常也需要覆盖<code>hashCode()</code>方法，以确保相等的对象具有相同的哈希码。这有助于提高哈希表在使用自定义类的对象作为键时的准确性。</p>
<h4 id="x3D-x3D-Java值传递与引用传递-x3D-x3D"><a href="#x3D-x3D-Java值传递与引用传递-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java值传递与引用传递&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java值传递与引用传递&#x3D;&#x3D;</h4><ul>
<li>Java中的参数传递是按值传递的。</li>
<li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。</li>
<li>如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝</li>
</ul>
<h4 id="x3D-x3D-Java为什么无法实现真正的泛型-x3D-x3D"><a href="#x3D-x3D-Java为什么无法实现真正的泛型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java为什么无法实现真正的泛型&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java为什么无法实现真正的泛型&#x3D;&#x3D;</h4><ul>
<li>兼容性<ul>
<li>类型擦除实现了兼容性，Java 1.5之后的类可以使用泛型，而 Java 1.4之前没有使用泛型的类也可以保留，并且不用做任何修改就能在新版本的Java虚拟机上运行</li>
</ul>
</li>
<li>Pizza实现了真正的泛型：基本数据类型+包装器类型</li>
</ul>
<h4 id="x3D-x3D-Java反射-x3D-x3D"><a href="#x3D-x3D-Java反射-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Java反射&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java反射&#x3D;&#x3D;</h4><p>反射</p>
<ul>
<li>优点<ul>
<li><strong>开发通用框架</strong>：像Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>
<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法会选择动态代理的方式，而动态代理的底层技术就是反射。</li>
<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>
<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行Java虚拟机优化，加上反射的写法的确要复杂得多，所以性能差，在一些性能敏感的程序中应该避免使用反射</li>
</ul>
</li>
</ul>
<p>获取Class对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 通过类的全名获取 Class 对象</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.itwanger.s39.Writer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过调用实例的getClass()方法获取 Class 对象</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span> 
<span class="token class-name">Class</span> cls <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过类的字面量（类本身）获取对象</span>
<span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过Class对象获取构造方法Constructor对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Constructor</span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过Constructor对象初始化反射类对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> object <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获取要调用的方法的Method对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Method</span> setNameMethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Method</span> getNameMethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 反射访问私有字段和（构造）方法需要使用<code>Constructor/Field/Method.setAccessible(true)</code>绕开Java语言访问限制</p>
<p><code>invoke()</code> 方法执行</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">setNameMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
getNameMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>每一个类，不管最终生成了多少个对象，这些对象只会对应一个 Class 对象，这个 Class 对象是由Java虚拟机生成的，由它来获悉整个类的结构信息.<code>java.lang.Class</code>是所有反射API的入口</p>
<p>方法的反射调用，最终是由 Method 对象的 <code>invoke()</code> 方法完成</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">,</span>
        <span class="token class-name">InvocationTargetException</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果方法不允许被覆盖，进行权限检查</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>override<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> caller <span class="token operator">=</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 检查调用者是否具有访问权限</span>
            <span class="token function">checkAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 获取方法访问器（从 volatile 变量中读取）</span>
    <span class="token class-name">MethodAccessor</span> ma <span class="token operator">=</span> methodAccessor<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果访问器为空，尝试获取方法访问器</span>
        ma <span class="token operator">=</span> <span class="token function">acquireMethodAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 使用方法访问器调用方法，并返回结果</span>
    <span class="token keyword">return</span> ma<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// invoke() 方法实际上是委派给 MethodAccessor 接口来完成的</span>
<span class="token comment">// MethodAccessor 接口有三个实现类</span>
<span class="token comment">// MethodAccessorImpl是一个抽象类,另外两个具体的实现类继承了这个抽象类</span>
<span class="token comment">// NativeMethodAccessorImpl：通过本地方法来实现反射调用；</span>
<span class="token comment">// DelegatingMethodAccessorImpl：通过委派模式来实现反射调用；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="委派实现"><a href="#委派实现" class="headerlink" title="委派实现"></a>委派实现</h5><p><code>invoke()</code> 方法执行时，先调用DelegatingMethodAccessorImpl，然后调用NativeMethodAccessorImpl，最后再调用实际的方法。采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过Java到C&#x2F;C++再到 Java之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。临界点默认是15次</p>
<hr>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="x3D-x3D-进程和线程-x3D-x3D"><a href="#x3D-x3D-进程和线程-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;进程和线程&#x3D;&#x3D;"></a>&#x3D;&#x3D;进程和线程&#x3D;&#x3D;</h4><ul>
<li>进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。</li>
<li>线程，是进程的子任务，是CPU调度和分派的基本单位，实现了进程内部的并发。</li>
<li><strong>线程在进程下进行</strong></li>
<li><strong>进程之间不会相互影响，主线程结束将会导致整个进程结束</strong></li>
<li><strong>不同的进程数很难共享</strong></li>
<li><strong>同进程下的不同线程之间数据易共享</strong></li>
<li><strong>进程使用内存地址可以限定使用量</strong></li>
</ul>
<h4 id="x3D-x3D-创建线程的三种方式-x3D-x3D"><a href="#x3D-x3D-创建线程的三种方式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;创建线程的三种方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;创建线程的三种方式&#x3D;&#x3D;</h4><ol>
<li><p>继承Thread类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个类继承Thread类，并重写run方法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>实现Runnable接口</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建一个类实现Runnable接口，并重写run方法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>实现Callable接口</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 实现Callable接口，重写call方法，这种方式可以通过FutureTask获取任务执行的返回值</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallerTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">"..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//创建异步任务</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//启动线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//等待执行完成，并获取返回结果</span>
            <span class="token class-name">String</span> result<span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h5 id="重写run方法"><a href="#重写run方法" class="headerlink" title="重写run方法"></a>重写run方法</h5><ul>
<li>默认的<code>run()</code>方法不会做任何事情。为了让线程执行实际任务，需要提供<code>run()</code>方法实现</li>
</ul>
<h5 id="run方法和start方法区别"><a href="#run方法和start方法区别" class="headerlink" title="run方法和start方法区别"></a>run方法和start方法区别</h5><ul>
<li><code>run()</code>：封装线程执行的代码，直接调用相当于调用普通方法</li>
<li><code>start()</code>：启动线程，然后由JVM调用此线程的<code>run()</code>方法</li>
</ul>
<h5 id="通过继承Thread的方法和实现Runnable-接口的方式创建多线程哪个好"><a href="#通过继承Thread的方法和实现Runnable-接口的方式创建多线程哪个好" class="headerlink" title="通过继承Thread的方法和实现Runnable 接口的方式创建多线程哪个好"></a><strong>通过继承Thread的方法和实现Runnable 接口的方式创建多线程哪个好</strong></h5><ul>
<li>实现 Runable 接口好，原因有两个：<ul>
<li>避免了Java单继承的局限性，Java不支持多重继承，因此如果类已经继承了另一个类，就不能再继承Thread类</li>
<li>适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable接口与Runnable非常相似，但可以返回一个结果</li>
</ul>
</li>
</ul>
<h5 id="线程控制方法"><a href="#线程控制方法" class="headerlink" title="线程控制方法"></a>线程控制方法</h5><ul>
<li><code>sleep()</code> 使当前正在执行的线程暂停指定毫秒数，进入休眠状态。使用sleep会发生异常要显示处理</li>
<li><code>join()</code>  等待该线程执行完才会轮到后续线程得到cpu的执行权。使用join要捕获异常</li>
<li><code>setDaemon()</code> 将此线程标记为守护线程，服务其他线程。</li>
<li><code>yield()</code> 静态方法，暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和JVM的线程调度策略。</li>
</ul>
<h5 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h5><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/wangzhe-thread-04.png" alt="img" style="zoom: 50%;" />

<h4 id="x3D-x3D-获取Java线程执行结果-x3D-x3D"><a href="#x3D-x3D-获取Java线程执行结果-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;获取Java线程执行结果&#x3D;&#x3D;"></a>&#x3D;&#x3D;获取Java线程执行结果&#x3D;&#x3D;</h4><ul>
<li>直接继承Thread或实现Runnable接口，重写的run方法返回类型void，无法获取执行结果</li>
<li>如果需要获取执行结果，就必须通过共享变量或者线程通信的方式来达到目的，使用起来较麻烦</li>
<li>Java 1.5提供了Callable、Future、FutureTask，可以在任务执行完后得到执行结果</li>
</ul>
<h5 id="有返回值的Callable"><a href="#有返回值的Callable" class="headerlink" title="有返回值的Callable"></a>有返回值的Callable</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Callable接口位于java.util.concurrent包下。定义了一个 call() 方法</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// Callable一般会配合 ExecutorService使用。</span>
<span class="token comment">// ExecutorService接口位于java.util.concurrent包下，</span>
<span class="token comment">// 是Java线程池框架的核心接口，用来异步执行任务。提供了一些关键方法用来进行线程管理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="异步计算结果Future接口"><a href="#异步计算结果Future接口" class="headerlink" title="异步计算结果Future接口"></a>异步计算结果Future接口</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Future接口位于java.util.concurrent包下</span>
<span class="token comment">// 提供三种功能： 判断任务是否完成，中断任务，获取任务执行结果</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 取消任务</span>
    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 任务是否被取消成功</span>
    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 任务是否已完成</span>
    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取执行结果。该方法产生阻塞，一直等到任务执行完毕才返回</span>
    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取执行结果。指定时间内未获取返回null</span>
    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="异步计算结果FutureTask实现类"><a href="#异步计算结果FutureTask实现类" class="headerlink" title="异步计算结果FutureTask实现类"></a>异步计算结果FutureTask实现类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">V</span> result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><hr>
<h5 id="x3D-x3D-和-equals"><a href="#x3D-x3D-和-equals" class="headerlink" title="&#x3D;&#x3D; 和 equals()"></a>&#x3D;&#x3D; 和 equals()</h5><ul>
<li><p>“&#x3D;&#x3D;”运算符比较的时候，如果两个对象都为null，并不会发生<code>NullPointerException</code>，而<code>equals()</code>方法会</p>
</li>
<li><p>“&#x3D;&#x3D;”运算符会在编译时进行检查，如果两侧的类型不匹配会提示错误，而<code>equals()</code>方法则不会</p>
</li>
</ul>
<h5 id="LinkedList和ArrayDeque"><a href="#LinkedList和ArrayDeque" class="headerlink" title="LinkedList和ArrayDeque"></a>LinkedList和ArrayDeque</h5><p>都是Java集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。</p>
<p>不过，LinkedList和ArrayDeque在实现上有一些不同：</p>
<ul>
<li>底层实现方式不同：LinkedList是基于链表实现的，而ArrayDeque是基于数组实现的。</li>
<li>随机访问的效率不同：由于底层实现方式的不同，LinkedList 对于随机访问的效率较低，时间复杂度为O(n)，而 ArrayDeque 可以通过下标随机访问元素，时间复杂度为O(1)。</li>
<li>迭代器的效率不同：LinkedList对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 ArrayDeque的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。</li>
<li>内存占用不同：由于LinkedList 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而ArrayDeque 是基于数组实现的，内存占用相对较低。</li>
</ul>
<h5 id="Java取模和取余"><a href="#Java取模和取余" class="headerlink" title="Java取模和取余"></a>Java取模和取余</h5><p>取模运算（Modulo Operation）和取余运算（Remainder Operation）</p>
<p>从严格意义上来讲，是两种不同的运算方式，它们在计算机中的实现也不同。</p>
<p>在Java中，通常使用%运算符来表示取余，用<code>Math.floorMod()</code>来表示取模。</p>
<ul>
<li>当操作数都是正数的话，结果一样</li>
<li>只有当操作数出现负数的情况，结果不同。</li>
<li><strong>取模运算的商向负无穷靠近；取余运算的商向0靠近</strong>。这是导致它们两个在处理有负数情况下结果不同的根本原因。</li>
<li>当数组的长度是2的n次方或n次幂或n的整数倍时，取模运算&#x2F;取余运算可以用位运算来代替，效率更高。</li>
</ul>
<h5 id="Compator-reverseOrder"><a href="#Compator-reverseOrder" class="headerlink" title="Compator.reverseOrder()"></a>Compator.reverseOrder()</h5><p><code>Comparator.reverseOrder()</code>返回的是Collections.ReverseComparator对象，用来反转顺序的，非常方便</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReverseComparator</span>
        <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 单例模式，用于表示逆序比较器</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ReverseComparator</span> REVERSE_ORDER
            <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReverseComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> c1<span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> c2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 反序列化时，返回Collections.reverseOrder()，保证单例模式</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 返回正序比较器</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Java的四种引用类型"><a href="#Java的四种引用类型" class="headerlink" title="Java的四种引用类型"></a>Java的四种引用类型</h5><ul>
<li>强引用(Strong Reference)，<ul>
<li>正常编码时默认的引用类型。如果一个对象到GC Roots强引用可到达，就可以阻止GC回收该对象</li>
</ul>
</li>
<li>软引用（Soft Reference）<ul>
<li>阻止GC回收的能力相对弱一些。软引用可以到达，则该对象会停留在内存更时间上长一些。</li>
<li>当内存不足时垃圾回收器才会回收这些软引用可到达的对象</li>
</ul>
</li>
<li>弱引用（WeakReference）<ul>
<li>无法阻止GC回收。弱引用可到达，则在下一个GC回收执行时，该对象就会被回收掉。</li>
</ul>
</li>
<li>虚引用（Phantom Reference）<ul>
<li>十分脆弱。唯一作用是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁</li>
</ul>
</li>
</ul>
<h5 id="Java引用队列-Reference-Queue"><a href="#Java引用队列-Reference-Queue" class="headerlink" title="Java引用队列(Reference Queue)"></a>Java引用队列(Reference Queue)</h5><ul>
<li>一般情况下，一个对象标记为垃圾（并不代表回收）后，会加入到引用队列。</li>
<li>对于虚引用来说，它指向的对象会只有被回收后才会加入引用队列，所以可以用作记录该引用指向的对象是否回收。</li>
</ul>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><p>Java中相对路径通常是相对于当前Java程序所在的目录</p>
<p>Windows操作系统中，文件系统默认不区分大小写； macOS和Linux等Unix系统中，文件系统默认是区分大小写</p>
<h5 id="回车符-amp-换行符"><a href="#回车符-amp-换行符" class="headerlink" title="回车符&amp;换行符"></a>回车符&amp;换行符</h5><p>回车符（<code>\r</code>）和换行符（<code>\n</code>）用于表示一行结束或者换行的操作。在不同操作系统和编程语言中使用方式可能有所不同</p>
<ul>
<li>在Windows系统中，通常使用回车符和换行符的组合（<code>\r\n</code>）来表示一行的结束</li>
<li>在macOS和Linux系统中，通常只使用换行符（<code>\n</code>）来表示一行的结束</li>
</ul>
<h5 id="级联问题（Cascade-Problem）"><a href="#级联问题（Cascade-Problem）" class="headerlink" title="级联问题（Cascade Problem）"></a>级联问题（Cascade Problem）</h5><p>指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。</p>
<h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5><p>Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点</p>
<img src="https://cdn.tobebetterjavaer.com/studymore/char-byte-20230322174312.png" alt="img" style="zoom:33%;" />

<ul>
<li>ASCII字符集<ul>
<li>一种固定长度的编码方式，每个字符都使用7位二进制编码来表示</li>
<li>ASCII编码只能表示英文字母、数字和少量符号，不能表示其他语言文字和符号</li>
</ul>
</li>
<li>Unicode字符集<ul>
<li>UTF-8一种可变长度的编码方式，对于ASCII字符（码点范围为 <code>0x00~0x7F</code>），使用一个字节表示。对于其他 Unicode字符，使用两个、三个或四个字节表示。UTF-8编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。</li>
<li>UTF-16一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过65,000个码位）中的字符（码点范围为 <code>0x0000~0xFFFF</code>），使用两个字节表示。对于其他 Unicode 字符，使用四个字节表示。</li>
<li>UTF-32一种固定长度的编码方式，对于所有Unicode字符，使用四个字节表示</li>
</ul>
</li>
<li>GBK字符集<ul>
<li>GB2312字符集中的字符，同时还扩展了许多其他汉字字符和符号</li>
<li>采用双字节编码方式，一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。每个汉字占用2个字节。</li>
</ul>
</li>
</ul>
<h5 id="NoClassDefFoundError和ClassNotFoundException区别"><a href="#NoClassDefFoundError和ClassNotFoundException区别" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException区别"></a>NoClassDefFoundError和ClassNotFoundException区别</h5><p>都是由于系统运行时找不到要加载的类导致的，但是触发原因不一样</p>
<ul>
<li>NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是jar包缺失或者调用了初始化失败的类。</li>
<li>ClassNotFoundException：当动态加载Class对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了</li>
</ul>
<h5 id="System-exit"><a href="#System-exit" class="headerlink" title="System.exit()"></a>System.exit()</h5><ul>
<li>终止当前运行的Java虚拟机。参数用作状态码，非0表示异常终止，0表示正常退出程序</li>
<li>该方法调用Runtime类中的exit方法，此方法不会正常返回</li>
</ul>
<h5 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h5><p>直接缓冲区和非直接缓冲区的差别主要在于它们在内存中的存储方式。</p>
<img src="https://cdn.tobebetterjavaer.com/stutymore/buffer-channel-selector-20230406182921.png" alt="img" style="zoom: 33%;" />

<p>非直接缓冲区：</p>
<ul>
<li>分配在JVM堆内存中</li>
<li>受到垃圾回收的管理</li>
<li>在读写操作时，需要将数据从堆内存复制到操作系统的本地内存，再进行I&#x2F;O操作</li>
<li>创建： <code>ByteBuffer.allocate(int capacity)</code></li>
</ul>
<p>直接缓冲区：</p>
<ul>
<li>分配在操作系统的本地内存中</li>
<li>不受垃圾回收的管理</li>
<li>在读写操作时，直接在本地内存中进行，避免了数据复制，提高了性能</li>
<li>创建： <ul>
<li><code>ByteBuffer.allocateDirect(int capacity)</code></li>
<li><code>FileChannel.map()</code> 方法，会返回一个类型为MappedByteBuffer的直接缓冲区。</li>
</ul>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://ephemeral-rose.github.io/2024/06/20/JavaSE/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://ephemeral-rose.github.io/2024/06/20/JavaSE/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"position":"right","hOffset":0,"vOffset":-200,"width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>



 	
</html>
